diff --git a/CMakeExternals/ITK-4.13.3_OpenSlide.patch b/CMakeExternals/ITK-4.13.3_OpenSlide.patch
new file mode 100644
index 0000000000..52bdbe6f78
--- /dev/null
+++ b/CMakeExternals/ITK-4.13.3_OpenSlide.patch
@@ -0,0 +1,2350 @@
+diff --git a/Modules/IO/OpenSlide/CMakeLists.txt b/Modules/IO/OpenSlide/CMakeLists.txt
+new file mode 100644
+index 0000000..b2f02fd
+--- /dev/null
++++ b/Modules/IO/OpenSlide/CMakeLists.txt
+@@ -0,0 +1,11 @@
++project(ITKIOOpenSlide)
++set(ITKIOOpenSlide_LIBRARIES ITKIOOpenSlide)
++
++set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})
++find_package( OpenSlide REQUIRED )
++if(NOT OPENSLIDE_FOUND)
++  message(FATAL_ERROR "Please specify OPENSLIDE_LIBRARY and OPENSLIDE_INCLUDE_DIR.")
++endif()
++
++
++itk_module_impl()
+diff --git a/Modules/IO/OpenSlide/LICENSE b/Modules/IO/OpenSlide/LICENSE
+new file mode 100644
+index 0000000..d645695
+--- /dev/null
++++ b/Modules/IO/OpenSlide/LICENSE
+@@ -0,0 +1,202 @@
++
++                                 Apache License
++                           Version 2.0, January 2004
++                        http://www.apache.org/licenses/
++
++   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
++
++   1. Definitions.
++
++      "License" shall mean the terms and conditions for use, reproduction,
++      and distribution as defined by Sections 1 through 9 of this document.
++
++      "Licensor" shall mean the copyright owner or entity authorized by
++      the copyright owner that is granting the License.
++
++      "Legal Entity" shall mean the union of the acting entity and all
++      other entities that control, are controlled by, or are under common
++      control with that entity. For the purposes of this definition,
++      "control" means (i) the power, direct or indirect, to cause the
++      direction or management of such entity, whether by contract or
++      otherwise, or (ii) ownership of fifty percent (50%) or more of the
++      outstanding shares, or (iii) beneficial ownership of such entity.
++
++      "You" (or "Your") shall mean an individual or Legal Entity
++      exercising permissions granted by this License.
++
++      "Source" form shall mean the preferred form for making modifications,
++      including but not limited to software source code, documentation
++      source, and configuration files.
++
++      "Object" form shall mean any form resulting from mechanical
++      transformation or translation of a Source form, including but
++      not limited to compiled object code, generated documentation,
++      and conversions to other media types.
++
++      "Work" shall mean the work of authorship, whether in Source or
++      Object form, made available under the License, as indicated by a
++      copyright notice that is included in or attached to the work
++      (an example is provided in the Appendix below).
++
++      "Derivative Works" shall mean any work, whether in Source or Object
++      form, that is based on (or derived from) the Work and for which the
++      editorial revisions, annotations, elaborations, or other modifications
++      represent, as a whole, an original work of authorship. For the purposes
++      of this License, Derivative Works shall not include works that remain
++      separable from, or merely link (or bind by name) to the interfaces of,
++      the Work and Derivative Works thereof.
++
++      "Contribution" shall mean any work of authorship, including
++      the original version of the Work and any modifications or additions
++      to that Work or Derivative Works thereof, that is intentionally
++      submitted to Licensor for inclusion in the Work by the copyright owner
++      or by an individual or Legal Entity authorized to submit on behalf of
++      the copyright owner. For the purposes of this definition, "submitted"
++      means any form of electronic, verbal, or written communication sent
++      to the Licensor or its representatives, including but not limited to
++      communication on electronic mailing lists, source code control systems,
++      and issue tracking systems that are managed by, or on behalf of, the
++      Licensor for the purpose of discussing and improving the Work, but
++      excluding communication that is conspicuously marked or otherwise
++      designated in writing by the copyright owner as "Not a Contribution."
++
++      "Contributor" shall mean Licensor and any individual or Legal Entity
++      on behalf of whom a Contribution has been received by Licensor and
++      subsequently incorporated within the Work.
++
++   2. Grant of Copyright License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      copyright license to reproduce, prepare Derivative Works of,
++      publicly display, publicly perform, sublicense, and distribute the
++      Work and such Derivative Works in Source or Object form.
++
++   3. Grant of Patent License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      (except as stated in this section) patent license to make, have made,
++      use, offer to sell, sell, import, and otherwise transfer the Work,
++      where such license applies only to those patent claims licensable
++      by such Contributor that are necessarily infringed by their
++      Contribution(s) alone or by combination of their Contribution(s)
++      with the Work to which such Contribution(s) was submitted. If You
++      institute patent litigation against any entity (including a
++      cross-claim or counterclaim in a lawsuit) alleging that the Work
++      or a Contribution incorporated within the Work constitutes direct
++      or contributory patent infringement, then any patent licenses
++      granted to You under this License for that Work shall terminate
++      as of the date such litigation is filed.
++
++   4. Redistribution. You may reproduce and distribute copies of the
++      Work or Derivative Works thereof in any medium, with or without
++      modifications, and in Source or Object form, provided that You
++      meet the following conditions:
++
++      (a) You must give any other recipients of the Work or
++          Derivative Works a copy of this License; and
++
++      (b) You must cause any modified files to carry prominent notices
++          stating that You changed the files; and
++
++      (c) You must retain, in the Source form of any Derivative Works
++          that You distribute, all copyright, patent, trademark, and
++          attribution notices from the Source form of the Work,
++          excluding those notices that do not pertain to any part of
++          the Derivative Works; and
++
++      (d) If the Work includes a "NOTICE" text file as part of its
++          distribution, then any Derivative Works that You distribute must
++          include a readable copy of the attribution notices contained
++          within such NOTICE file, excluding those notices that do not
++          pertain to any part of the Derivative Works, in at least one
++          of the following places: within a NOTICE text file distributed
++          as part of the Derivative Works; within the Source form or
++          documentation, if provided along with the Derivative Works; or,
++          within a display generated by the Derivative Works, if and
++          wherever such third-party notices normally appear. The contents
++          of the NOTICE file are for informational purposes only and
++          do not modify the License. You may add Your own attribution
++          notices within Derivative Works that You distribute, alongside
++          or as an addendum to the NOTICE text from the Work, provided
++          that such additional attribution notices cannot be construed
++          as modifying the License.
++
++      You may add Your own copyright statement to Your modifications and
++      may provide additional or different license terms and conditions
++      for use, reproduction, or distribution of Your modifications, or
++      for any such Derivative Works as a whole, provided Your use,
++      reproduction, and distribution of the Work otherwise complies with
++      the conditions stated in this License.
++
++   5. Submission of Contributions. Unless You explicitly state otherwise,
++      any Contribution intentionally submitted for inclusion in the Work
++      by You to the Licensor shall be under the terms and conditions of
++      this License, without any additional terms or conditions.
++      Notwithstanding the above, nothing herein shall supersede or modify
++      the terms of any separate license agreement you may have executed
++      with Licensor regarding such Contributions.
++
++   6. Trademarks. This License does not grant permission to use the trade
++      names, trademarks, service marks, or product names of the Licensor,
++      except as required for reasonable and customary use in describing the
++      origin of the Work and reproducing the content of the NOTICE file.
++
++   7. Disclaimer of Warranty. Unless required by applicable law or
++      agreed to in writing, Licensor provides the Work (and each
++      Contributor provides its Contributions) on an "AS IS" BASIS,
++      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++      implied, including, without limitation, any warranties or conditions
++      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
++      PARTICULAR PURPOSE. You are solely responsible for determining the
++      appropriateness of using or redistributing the Work and assume any
++      risks associated with Your exercise of permissions under this License.
++
++   8. Limitation of Liability. In no event and under no legal theory,
++      whether in tort (including negligence), contract, or otherwise,
++      unless required by applicable law (such as deliberate and grossly
++      negligent acts) or agreed to in writing, shall any Contributor be
++      liable to You for damages, including any direct, indirect, special,
++      incidental, or consequential damages of any character arising as a
++      result of this License or out of the use or inability to use the
++      Work (including but not limited to damages for loss of goodwill,
++      work stoppage, computer failure or malfunction, or any and all
++      other commercial damages or losses), even if such Contributor
++      has been advised of the possibility of such damages.
++
++   9. Accepting Warranty or Additional Liability. While redistributing
++      the Work or Derivative Works thereof, You may choose to offer,
++      and charge a fee for, acceptance of support, warranty, indemnity,
++      or other liability obligations and/or rights consistent with this
++      License. However, in accepting such obligations, You may act only
++      on Your own behalf and on Your sole responsibility, not on behalf
++      of any other Contributor, and only if You agree to indemnify,
++      defend, and hold each Contributor harmless for any liability
++      incurred by, or claims asserted against, such Contributor by reason
++      of your accepting any such warranty or additional liability.
++
++   END OF TERMS AND CONDITIONS
++
++   APPENDIX: How to apply the Apache License to your work.
++
++      To apply the Apache License to your work, attach the following
++      boilerplate notice, with the fields enclosed by brackets "[]"
++      replaced with your own identifying information. (Don't include
++      the brackets!)  The text should be enclosed in the appropriate
++      comment syntax for the file format. We also recommend that a
++      file or class name and description of purpose be included on the
++      same "printed page" as the copyright notice for easier
++      identification within third-party archives.
++
++   Copyright [yyyy] [name of copyright owner]
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
+diff --git a/Modules/IO/OpenSlide/README.rst b/Modules/IO/OpenSlide/README.rst
+new file mode 100644
+index 0000000..b5bacbf
+--- /dev/null
++++ b/Modules/IO/OpenSlide/README.rst
+@@ -0,0 +1,39 @@
++ITKIOOpenSlide
++==============
++
++.. |CircleCI| image:: https://circleci.com/gh/InsightSoftwareConsortium/ITKIOOpenSlide.svg?style=shield
++    :target: https://circleci.com/gh/InsightSoftwareConsortium/ITKIOOpenSlide
++
++.. |TravisCI| image:: https://travis-ci.org/InsightSoftwareConsortium/ITKIOOpenSlide.svg?branch=master
++    :target: https://travis-ci.org/InsightSoftwareConsortium/ITKIOOpenSlide
++
++.. |AppVeyor| image:: https://img.shields.io/appveyor/ci/itkrobot/itkioopenslide.svg
++    :target: https://ci.appveyor.com/project/itkrobot/itkioopenslide
++
++=========== =========== ===========
++   Linux      macOS       Windows
++=========== =========== ===========
++|CircleCI|  |TravisCI|  |AppVeyor|
++=========== =========== ===========
++
++
++Overview
++--------
++
++This is an InsightToolkit (ITK) ExternalModule to provide an ImageIO for the
++OpenSlide library supported file formats. These are generally TIFF-based
++microscopy formats.
++
++To use this module, clone it into the Modules/External directory in the ITK
++source tree.
++
++Note that the OpenSlide library (http://openslide.org) must be available.
++
++*Note:*  This module is currently a work in progress.
++
++
++License
++-------
++
++This software is distributed under the Apache 2.0 license. Please see
++the *LICENSE* file for details.
+diff --git a/Modules/IO/OpenSlide/cmake/FindOpenSlide.cmake b/Modules/IO/OpenSlide/cmake/FindOpenSlide.cmake
+new file mode 100644
+index 0000000..c1d9aa2
+--- /dev/null
++++ b/Modules/IO/OpenSlide/cmake/FindOpenSlide.cmake
+@@ -0,0 +1,29 @@
++# A CMake find module for the OpenSlide microscopy file reader library.
++#
++# http://openslide.org
++#
++# Once done, this module will define
++#   OPENSLIDE_FOUND         - system has OpenSlide
++#   OPENSLIDE_INCLUDE_DIRS  - the OpenSlide include directory
++#   OPENSLIDE_LIBRARIES     - link to these to use OpenSlide
++
++# Look for the header.
++find_path(OPENSLIDE_INCLUDE_DIR NAMES openslide.h
++  PATH_SUFFIXES openslide
++  )
++mark_as_advanced(OPENSLIDE_INCLUDE_DIR)
++
++# Look for the library.
++find_library(OPENSLIDE_LIBRARY NAMES openslide)
++mark_as_advanced(OPENSLIDE_LIBRARY)
++
++# Handle the QUIETLY and REQUIRED arguments and set OPENSLIDE_FOUND true if all
++# the listed variables are TRUE.
++
++find_package(PackageHandleStandardArgs)
++FIND_PACKAGE_HANDLE_STANDARD_ARGS(OPENSLIDE DEFAULT_MSG OPENSLIDE_LIBRARY OPENSLIDE_INCLUDE_DIR)
++
++if(OPENSLIDE_FOUND)
++  set(OPENSLIDE_LIBRARIES ${OPENSLIDE_LIBRARY})
++  set(OPENSLIDE_INCLUDE_DIRS ${OPENSLIDE_INCLUDE_DIR})
++endif()
+diff --git a/Modules/IO/OpenSlide/include/itkOpenSlideImageIO.h b/Modules/IO/OpenSlide/include/itkOpenSlideImageIO.h
+new file mode 100644
+index 0000000..a2f8376
+--- /dev/null
++++ b/Modules/IO/OpenSlide/include/itkOpenSlideImageIO.h
+@@ -0,0 +1,175 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++#ifndef itkOpenSlideImageIO_h
++#define itkOpenSlideImageIO_h
++
++#include "itkImageIOBase.h"
++#include "ITKIOOpenSlideExport.h"
++
++namespace itk
++{
++
++	// Forward declare a wrapper class that is responsible for openslide_t (among other things)
++	class OpenSlideWrapper;
++
++	/** \class OpenSlideImageIO
++	 *
++	 * \brief OpenSlide is a C library that provides a simple interface to read whole-slide
++	 * images (also known as virtual slides). The following formats can be read:
++	 *
++	 * - Trestle (.tif),
++	 * - Hamamatsu (.vms, .vmu, .ndpi)
++	 * - Aperio (.svs, .tif)
++	 * - MIRAX (.mrxs)
++	 * - Leica (.scn)
++	 * - Sakura (.svslide)
++	 * - Ventana (.bif, .tif)
++	 * - Philips (.tiff)
++	 * - Generic tiled TIFF (.tif)
++	 *
++	 *  \warning Streaming level images other than level 0 may not give pixel-by-pixel
++	 *  identical images as reading the image in all at once.
++	 *
++	 *  \ingroup IOFilters
++	 *
++	 *  \ingroup IOOpenSlide
++	 */
++	class ITKIOOpenSlide_EXPORT OpenSlideImageIO : public ImageIOBase
++	{
++	public:
++
++
++		/** Standard class type alias. */
++		using Self = OpenSlideImageIO;
++		using Superclass = ImageIOBase;
++		using Pointer = SmartPointer<Self>;
++		using AssociatedImageNameContainer = std::vector<std::string>;
++
++		/** Method for creation through the object factory. */
++		itkNewMacro(Self);
++
++		/** Run-time type information (and related methods). */
++		itkTypeMacro(OpenSlideImageIO, ImageIOBase);
++
++		using ArrayOfExtensionsType = Superclass::ArrayOfExtensionsType;
++
++		/*-------- This part of the interfaces deals with reading data. ----- */
++
++		 /** Determine the file type. Returns true if this ImageIO can read the
++		  * file specified. */
++		virtual bool CanReadFile(const char*);
++
++		/** Determine if the ImageIO can stream reading from the
++			current settings. Default is false. If this is queried after
++			the header of the file has been read then it will indicate if
++			that file can be streamed */
++		virtual bool CanStreamRead();
++
++		/** Set the spacing and dimension information for the set filename. */
++		virtual void ReadImageInformation();
++
++		/** Reads the data from disk into the memory buffer provided. */
++		virtual void Read(void* buffer);
++
++		/*-------- This part of the interfaces deals with writing data. ----- */
++
++		/** Determine the file type. Returns true if this ImageIO can write the
++		 * file specified. */
++		virtual bool CanWriteFile(const char*);
++
++		/** Set the spacing and dimension information for the set filename. */
++		virtual void WriteImageInformation();
++
++		/** Writes the data to disk from the memory buffer provided. Make sure
++		 * that the IORegions has been set properly. */
++		virtual void Write(const void* buffer);
++
++		/** Method for supporting streaming.  Given a requested region, determine what
++		 * could be the region that we can read from the file. This is called the
++		 * streamable region, which will be smaller than the LargestPossibleRegion and
++		 * greater or equal to the RequestedRegion */
++		virtual ImageIORegion
++			GenerateStreamableReadRegionFromRequestedRegion(const ImageIORegion & requested) const;
++
++		/** Get underlying OpenSlide library version */
++		virtual std::string GetOpenSlideVersion() const;
++
++		/** Detect the vendor of the current file. */
++		virtual std::string GetVendor() const;
++
++		/** Sets the level to read. Level 0 (default) is the highest resolution level.
++		 * This method overrides any previously selected associated image.
++		 * Call ReadImageInformation() again after calling this function. */
++		virtual void SetLevel(int iLevel);
++
++		/** Returns the currently selected level. */
++		virtual int GetLevel() const;
++
++		/** Returns the number of available levels. */
++		virtual int GetLevelCount() const;
++
++		/** Sets the associated image to extract.
++		 * This method overrides any previously selected level.
++		 * Call ReadImageInformation() again after calling this function. */
++		virtual void SetAssociatedImageName(const std::string &strName);
++
++		/** Returns the currently selected associated image name (empty string if none). */
++		virtual std::string GetAssociatedImageName() const;
++
++		/** Sets the best level to read for the given downsample factor.
++		 * This method overrides any previously selected associated image.
++		 * Call ReadImageInformation() again after calling this function. */
++		virtual bool SetLevelForDownsampleFactor(double dDownsampleFactor);
++
++		/** Returns all associated image names stored in the file. */
++		virtual AssociatedImageNameContainer GetAssociatedImageNames() const;
++
++		/** Returns the absolute maximum number of streamable regions (tiles). */
++		virtual int64_t ComputeMaximumNumberOfStreamableRegions() const;
++
++		/** Returns the maximum number of streamable regions similar (but >=) to the given region. */
++		virtual int64_t ComputeMaximumNumberOfStreamableRegions(const ImageIORegion &clRegion) const;
++
++		/** Returns the minimum streamable region. */
++		virtual ImageIORegion GetMinimumStreamableRegion() const;
++
++		/** Turn on/off approximate streaming. This only affects streaming level images other than level 0.
++		  * This gives the ImageIO more flexibility with the read regions allowing for more streaming divisons
++		  * at the cost of image accuracy. This flexibility is already available for level 0 whether this is
++		  * enabled or not (and does not affect accuracy).
++		  * Use this if streaming results in excessive memory usage when streaming level images other than
++		  * level 0.
++		  */
++		virtual void SetApproximateStreaming(bool bApproximateStreaming);
++
++		/** Returns whether approximate streaming is enabled or not. */
++		virtual bool GetApproximateStreaming() const;
++
++	protected:
++		OpenSlideImageIO();
++		~OpenSlideImageIO();
++		virtual void PrintSelf(std::ostream& os, Indent indent) const;
++
++	private:
++		ITK_DISALLOW_COPY_AND_ASSIGN(OpenSlideImageIO);
++		OpenSlideWrapper *m_OpenSlideWrapper; // Opaque pointer to a wrapper that manages openslide_t
++	};
++
++} // end namespace itk
++
++#endif // itkOpenSlideImageIO_h
+diff --git a/Modules/IO/OpenSlide/include/itkOpenSlideImageIOFactory.h b/Modules/IO/OpenSlide/include/itkOpenSlideImageIOFactory.h
+new file mode 100644
+index 0000000..7d1057b
+--- /dev/null
++++ b/Modules/IO/OpenSlide/include/itkOpenSlideImageIOFactory.h
+@@ -0,0 +1,75 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++#ifndef itkOpenSlideImageIOFactory_h
++#define itkOpenSlideImageIOFactory_h
++
++#include "itkObjectFactoryBase.h"
++#include "itkImageIOBase.h"
++#include "itkMacro.h"
++#include "ITKIOOpenSlideExport.h"
++
++namespace itk
++{
++/** \class OpenSlideImageIOFactory
++ *
++ * \brief OpenSlide is a C library that provides a simple interface
++ * to read whole-slide images (also known as virtual slides).
++ *
++ * \ingroup IOOpenSlide
++ *
++ */
++class ITKIOOpenSlide_EXPORT OpenSlideImageIOFactory : public ObjectFactoryBase
++{
++public:
++
++
++  /** Standard class type alias. */
++  using Self = OpenSlideImageIOFactory;
++  using Superclass = ObjectFactoryBase;
++  using Pointer = SmartPointer<Self>;
++  using ConstPointer = SmartPointer<const Self>;
++
++  /** Class methods used to interface with the registered factories. */
++  virtual const char* GetITKSourceVersion() const;
++  virtual const char* GetDescription() const;
++
++  /** Method for class instantiation. */
++  itkFactorylessNewMacro(Self);
++  static OpenSlideImageIOFactory* FactoryNew() { return new OpenSlideImageIOFactory;}
++
++  /** Run-time type information (and related methods). */
++  itkTypeMacro(OpenSlideImageIOFactory, ObjectFactoryBase);
++
++  /** Register one factory of this type  */
++  static void RegisterOneFactory()
++    {
++    OpenSlideImageIOFactory::Pointer metaFactory = OpenSlideImageIOFactory::New();
++    ObjectFactoryBase::RegisterFactory(metaFactory);
++    }
++
++protected:
++  OpenSlideImageIOFactory();
++  ~OpenSlideImageIOFactory();
++
++private:
++	ITK_DISALLOW_COPY_AND_ASSIGN(OpenSlideImageIOFactory);
++};
++
++} // end namespace itk
++
++#endif
+diff --git a/Modules/IO/OpenSlide/itk-module.cmake b/Modules/IO/OpenSlide/itk-module.cmake
+new file mode 100644
+index 0000000..9789423
+--- /dev/null
++++ b/Modules/IO/OpenSlide/itk-module.cmake
+@@ -0,0 +1,15 @@
++set( DOCUMENTATION "This module contains ImageIO classes for reading microscopy
++images (mostly TIFF based) readable by the OpenSlide library,
++http://openslide.org.")
++
++itk_module(ITKIOOpenSlide
++  ENABLE_SHARED
++  PRIVATE_DEPENDS
++    ITKIOImageBase
++  TEST_DEPENDS
++    ITKTestKernel
++  FACTORY_NAMES
++    ImageIO::OpenSlide
++  DESCRIPTION
++    "${DOCUMENTATION}"
++)
+diff --git a/Modules/IO/OpenSlide/src/CMakeLists.txt b/Modules/IO/OpenSlide/src/CMakeLists.txt
+new file mode 100644
+index 0000000..9a05c57
+--- /dev/null
++++ b/Modules/IO/OpenSlide/src/CMakeLists.txt
+@@ -0,0 +1,8 @@
++set(ITKIOOpenSlide_SRCS
++  itkOpenSlideImageIOFactory.cxx
++  itkOpenSlideImageIO.cxx
++  )
++
++include_directories(${OPENSLIDE_INCLUDE_DIRS})
++itk_module_add_library(ITKIOOpenSlide ${ITKIOOpenSlide_SRCS})
++target_link_libraries(ITKIOOpenSlide LINK_PRIVATE ${OPENSLIDE_LIBRARIES})
+diff --git a/Modules/IO/OpenSlide/src/itkOpenSlideImageIO.cxx b/Modules/IO/OpenSlide/src/itkOpenSlideImageIO.cxx
+new file mode 100644
+index 0000000..667f4cc
+--- /dev/null
++++ b/Modules/IO/OpenSlide/src/itkOpenSlideImageIO.cxx
+@@ -0,0 +1,868 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++
++#include <cctype>
++#include <algorithm>
++#include <sstream>
++
++#include "itkIOCommon.h"
++#include "itkOpenSlideImageIO.h"
++#include "itksys/SystemTools.hxx"
++#include "itkMetaDataDictionary.h"
++#include "itkMetaDataObject.h"
++
++// OpenSlide
++#include "openslide.h"
++
++namespace itk
++{
++
++// OpenSlide wrapper class
++// This is responsible for freeing the OpenSlide context on destruction
++// It also allows for seamless access to various levels and associated images through one set of functions (as opposed to two)
++class OpenSlideWrapper {
++public:
++
++  // GCD Algorithm from wikipedia pseudo code: 
++  // https://en.wikipedia.org/wiki/Greatest_common_divisor#Binary_method
++  // 
++  // NOTE: While vnl_rational can do this too, vnl_rational is defined for long integers (32 bit integers on amd64).
++  //       Slides can be extremely large. It would ideal to work with 64 bit integers.
++  static uint64_t GCD(uint64_t ui64A, uint64_t ui64B) {
++    if (ui64A == 0)
++      return ui64B;
++
++    if (ui64B == 0)
++      return ui64A;
++
++    if (ui64A == 1 || ui64B == 1)
++      return 1;
++
++    if (ui64A == ui64B)
++      return ui64A;
++
++    unsigned int uiExp = 0;
++    while ((ui64A & 1) == 0 && (ui64B & 1) == 0) {
++      ui64A >>= 1;
++      ui64B >>= 1;
++      ++uiExp;
++    }
++
++    while (ui64A != ui64B) {
++      if ((ui64A & 1) == 0)
++        ui64A >>= 1;
++      else if ((ui64B & 1) == 0)
++        ui64B >>= 1;
++      else if (ui64A > ui64B)
++        ui64A = (ui64A - ui64B) >> 1;
++      else
++        ui64B = (ui64B - ui64A) >> 1;
++    }
++
++    return ui64A << uiExp;
++  }
++
++  // Detects the vendor. Should return NULL if the file is not readable.
++  static const char * DetectVendor(const char *p_cFileName) {
++    return openslide_detect_vendor(p_cFileName);
++  }
++
++  // Weak check if the file can be read
++  static bool CanReadFile(const char *p_cFileName) {
++    return DetectVendor(p_cFileName) != NULL;
++  }
++
++  // Returns version of OpenSlide library
++  static const char * GetVersion() {
++    return openslide_get_version();
++  }
++
++  // Constructors
++  OpenSlideWrapper() {
++    m_Osr = NULL;
++    m_Level = 0;
++    m_ApproximateStreaming = false;
++  }
++
++  OpenSlideWrapper(const char *p_cFileName) {
++    m_Osr = NULL;
++    m_Level = 0;
++    m_ApproximateStreaming = false;
++    Open(p_cFileName);
++  }
++
++  // Destructor
++  ~OpenSlideWrapper() {
++    Close();
++  }
++
++  // Set whether streaming should be approximate or exact
++  void SetApproximateStreaming(bool bApproximateStreaming) {
++    m_ApproximateStreaming = bApproximateStreaming;
++  }
++
++  // Determine whether streaming is exact or approximate
++  bool GetApproximateStreaming() const {
++    return m_ApproximateStreaming;
++  }
++
++  // Tells the ImageIO if the wrapper is in a state where stream reading can occur.
++  // While OpenSlide supports reading regions of level images, it does not for associated images.
++  bool CanStreamRead() const {
++    if (m_AssociatedImage.size() > 0)
++      return false;
++
++    // XXX: ITK streams along X. Shouldn't we check if the minimum spacing in Y is not the size of the whole image?
++    return m_ApproximateStreaming || ComputeMaximumNumberOfStreamableRegions() > 1;
++  }
++
++  // Closes the currently opened file
++  void Close() {
++    if (m_Osr != NULL) {
++      openslide_close(m_Osr);
++      m_Osr = NULL;
++    }
++  }
++
++  // Checks weather a slide file is currently opened
++  bool IsOpened() const {
++    return m_Osr != NULL;
++  }
++
++  // Opens a slide file
++  bool Open(const char *p_cFileName) {
++    Close();
++    m_Osr = openslide_open(p_cFileName);
++    return m_Osr != NULL;
++  }
++
++  // Get error string, NULL if there is no error
++  const char * GetError() const {
++    if (m_Osr == NULL)
++      return "OpenSlideWrapper has no file open.";
++
++    return openslide_get_error(m_Osr);
++  }
++
++  // Sets the level that is accessible with ReadRegion, GetDimensions, GetSpacing.
++  // Clears any associated image context.
++  void SetLevel(int32_t i32Level) {
++    m_Level = i32Level;
++    m_AssociatedImage.clear();
++  }
++
++  // Returns the currently selected level
++  int32_t GetLevel() const {
++    return m_Level;
++  }
++
++  // Sets the associated image that is accessible with ReadRegion, GetDimensions
++  void SetAssociatedImageName(const std::string &strImageName) {
++    m_AssociatedImage = strImageName;
++    m_Level = 0;
++  }
++
++  // Returns the currently selected associated image
++  const std::string & GetAssociatedImageName() const {
++    return m_AssociatedImage;
++  }
++
++  // Given a downsample factor, uses OpenSlide to determine the best level to use.
++  bool SetBestLevelForDownsample(double dDownsample) {
++    if (m_Osr == NULL)
++      return false;
++
++    const int32_t i32Level = openslide_get_best_level_for_downsample(m_Osr, dDownsample);
++
++    if (i32Level < 0)
++      return false;
++
++    SetLevel(i32Level);
++
++    return true;
++  }
++
++  // Returns the number of levels in this file
++  int32_t GetLevelCount() const {
++    if (m_Osr == NULL)
++      return -1;
++
++    return openslide_get_level_count(m_Osr);
++  }
++
++  // Returns NULL for success
++  // NOTE: When reading associated images, x, y, width and height are ignored.
++  const char * ReadRegion(uint32_t *p_ui32Dest, int64_t i64X, int64_t i64Y, int64_t i64Width, int64_t i64Height) const {
++    if (m_Osr == NULL)
++      return "OpenSlideWrapper has no file open.";
++
++    if (m_AssociatedImage.size() > 0) {
++      openslide_read_associated_image(m_Osr, m_AssociatedImage.c_str(), p_ui32Dest);
++    }
++    else {
++      const double dDownsampleFactor = openslide_get_level_downsample(m_Osr, m_Level);
++
++      if (dDownsampleFactor <= 0.0)
++        return "Could not get downsample factor.";
++
++      // NOTE: API expects level 0 coordinates. So we upsample the coordinates.
++      // XXX: This can subtly change the image compared to reading all at once.
++      //      The handling of coordinates internally in OpenSlide is quite similar!
++      i64X = (int64_t)(i64X * dDownsampleFactor);
++      i64Y = (int64_t)(i64Y * dDownsampleFactor);
++
++      openslide_read_region(m_Osr, p_ui32Dest, i64X, i64Y, m_Level, i64Width, i64Height);
++    }
++
++    return openslide_get_error(m_Osr);
++  }
++
++  // Computes the spacing depending on selected level
++  // Default spacing is relative to 1 MPP if the function fails to detect spacing information (downsample factor is considered)
++  bool GetSpacing(double &dSpacingX, double &dSpacingY) const {
++    dSpacingX = dSpacingY = 1.0;
++
++    if (m_Osr == NULL)
++      return false;
++
++    if (m_AssociatedImage.size() > 0)
++      return false;
++
++    const double dDownsample = openslide_get_level_downsample(m_Osr, m_Level);
++
++    if (dDownsample <= 0.0)
++      return false;
++
++    if (!GetPropertyValue(OPENSLIDE_PROPERTY_NAME_MPP_X, dSpacingX) || !GetPropertyValue(OPENSLIDE_PROPERTY_NAME_MPP_Y, dSpacingY)) {
++      dSpacingX = dSpacingY = dDownsample;
++      return false;
++    }
++
++    dSpacingX *= dDownsample;
++    dSpacingY *= dDownsample;
++
++    return true;
++  }
++
++  // Returns the dimension of the level or associated image
++  bool GetDimensions(int64_t &i64Width, int64_t &i64Height) const {
++    i64Width = i64Height = 0;
++
++    if (m_Osr == NULL)
++      return false;
++
++    if (m_AssociatedImage.size() > 0)
++      openslide_get_associated_image_dimensions(m_Osr, m_AssociatedImage.c_str(), &i64Width, &i64Height);
++    else
++      openslide_get_level_dimensions(m_Osr, m_Level, &i64Width, &i64Height);
++
++    return i64Width > 0 && i64Height > 0;
++  }
++
++  // Retrieves associated image names from the open slide and places them into a std::vector
++  std::vector<std::string> GetAssociatedImageNames() const {
++    if (m_Osr == NULL)
++      return std::vector<std::string>();
++
++    const char * const * p_cNames = openslide_get_associated_image_names(m_Osr);
++
++    if (p_cNames == NULL)
++      return std::vector<std::string>();
++  
++    std::vector<std::string> vNames;
++
++    for (int i = 0; p_cNames[i] != NULL; ++i)
++      vNames.push_back(p_cNames[i]);
++
++    return vNames;
++  }
++
++  // Forms an ITK MetaDataDictionary
++  MetaDataDictionary GetMetaDataDictionary() const {
++    if (m_Osr == NULL)
++      return MetaDataDictionary();
++
++    MetaDataDictionary clTags;
++
++    const char * const * p_cNames = openslide_get_property_names(m_Osr);
++
++    if (p_cNames != NULL) {
++      std::string strValue;
++
++      for (int i = 0; p_cNames[i] != NULL; ++i) {
++        strValue.clear();
++
++        if (GetPropertyValue(p_cNames[i], strValue))
++          EncapsulateMetaData<std::string>(clTags, p_cNames[i], strValue);
++      }
++    }
++
++    return clTags;
++  }
++
++  // Templated functions for accessing and casting property values
++  template<typename ValueType>
++  bool GetPropertyValue(const char *p_cKey, ValueType &value) const {
++    if (m_Osr == NULL)
++      return false;
++
++    const char * const p_cValue = openslide_get_property_value(m_Osr, p_cKey);
++    if (p_cValue == NULL)
++      return false;
++
++    std::stringstream valueStream;
++
++    valueStream << p_cValue;
++    valueStream >> value;
++
++    return !valueStream.fail() && !valueStream.bad();
++  }
++
++  bool GetPropertyValue(const char *p_cKey, std::string &strValue) const {
++    if (m_Osr == NULL)
++      return false;
++
++    const char * const p_cValue = openslide_get_property_value(m_Osr, p_cKey);
++    if (p_cValue == NULL)
++      return false;
++
++    strValue = p_cValue;
++    return true;
++  }
++
++  // Compute the minimum streamable region size
++  // Explanation:
++  // OpenSlide expects level 0 coordinates in openslide_read_region(). This is OK if we're reading level 0 images.
++  // However, if we're reading level L images with L > 0, this becomes problematic. This can be seen with a little math.
++  // First, note the equation relating level 0 and level L coordinates:
++  //
++  // x_0 = D * x_L
++  //
++  // Here D is the downsample factor and is a real number (openslide_get_level_downsample() returns double).
++  // From OpenSlide's source code, OpenSlide downsamples x_0 to x_L with a floor operation:
++  //
++  // x_L = floor(x_0 / D)
++  //
++  // Likewise, OpenSlide upsamples x_0 with a floor operation
++  //
++  // x_0 = floor(x_L * D)
++  //
++  // In this implementation, ITK works with coordinates at the selected level. When L > 0, it becomes challenging
++  // to pick coordinates x_0 that identify x_L exactly. We derive x_0 by upsampling as above. But several values of x_0 will map to x_L.
++  // We need to pick x_L so that it is invariant to an upsample and subsequent downsample. In math we want x_L so that:
++  //
++  // x_L = Downsample(Upsample(x_L)) = floor(floor(x_L * D) / D)
++  //
++  // D is known to be a rational number A/B since it is computed by dividing the dimensions of level 0 and level L images.
++  // If A/B is a reduced fraction, we would like to determine x_L so that it is divisible by B. When B divides x_L we have the identity:
++  //
++  // Upsample(x_L) = D * x_L
++  //
++  // A subsequent downsample gives:
++  //
++  // Downsample(D * x_L) = x_L
++  //
++  // Which is what we wanted. Consequently, if dimensions are coprime, the image cannot technically be streamed.
++  // In that case the ImageIORegion would reflect entire level L image. 
++  // This wrapper also supports approximate streaming (ignoring this issue).
++  bool ComputeMinimumStreamableRegionSize(int64_t &i64Width, int64_t &i64Height) const {
++    i64Width = i64Height = 0;
++
++    if (m_Osr == NULL)
++      return false;
++
++    if (m_Level == 0 || m_ApproximateStreaming) { // Nothing to do
++      i64Width = i64Height = 1;
++      return true;
++    }
++
++    int64_t i64WidthLevel0 = 0, i64HeightLevel0 = 0;
++    int64_t i64WidthLevelL = 0, i64HeightLevelL = 0;
++
++    openslide_get_level0_dimensions(m_Osr, &i64WidthLevel0, &i64HeightLevel0);
++    openslide_get_level_dimensions(m_Osr, m_Level, &i64WidthLevelL, &i64HeightLevelL);
++
++    if (i64WidthLevel0 <= 0 || i64HeightLevel0 <= 0 || i64WidthLevelL <= 0 || i64HeightLevelL <= 0)
++      return false;
++
++    i64Width = i64WidthLevelL / (int64_t)GCD(i64WidthLevel0, i64WidthLevelL);
++    i64Height = i64HeightLevelL / (int64_t)GCD(i64HeightLevel0, i64HeightLevelL);
++
++    return true;
++  }
++
++  // Compute absolute maximum number of streamable regions
++  int64_t ComputeMaximumNumberOfStreamableRegions() const {
++    int64_t i64RegionWidth = 0, i64RegionHeight = 0;
++
++    if (!ComputeMinimumStreamableRegionSize(i64RegionWidth, i64RegionHeight))
++      return -1;
++
++    int64_t i64Width = 0, i64Height = 0;
++
++    openslide_get_level_dimensions(m_Osr, m_Level, &i64Width, &i64Height);
++
++    if (i64Width <= 0 || i64Height <= 0)
++      return -1;
++
++    // NOTE: The width and height are multiplies of region width and height
++    return (i64Width / i64RegionWidth) * (i64Height / i64RegionHeight);
++  }
++
++  // After alignment, what's the maximum number of streamable regions of this size?
++  int64_t ComputeMaximumNumberOfStreamableRegions(int64_t i64X, int64_t i64Y, int64_t i64Width, int64_t i64Height) const {
++    if (m_Osr == NULL)
++      return -1;
++
++    int64_t i64ImageWidth = 0, i64ImageHeight = 0;
++
++    openslide_get_level_dimensions(m_Osr, m_Level, &i64ImageWidth, &i64ImageHeight);
++
++    if (i64ImageWidth <= 0 || i64ImageHeight <= 0)
++      return -1;
++
++    if (!AlignReadRegion(i64X, i64Y, i64Width, i64Height))
++      return -1;
++
++    return (i64ImageWidth + i64Width - 1)/i64Width * (i64ImageHeight + i64Height - 1)/i64Height;
++  }
++
++  // Align X, Y and region dimensions to be on the grid of points invariant to upsample/downsample
++  bool AlignReadRegion(int64_t &i64X, int64_t &i64Y, int64_t &i64Width, int64_t &i64Height) const {
++    if (m_Osr == NULL)
++      return false;
++
++    if (m_Level == 0 || m_ApproximateStreaming) // Nothing to do
++      return true;
++
++    int64_t i64MinWidth = 0, i64MinHeight = 0;
++
++    if (!ComputeMinimumStreamableRegionSize(i64MinWidth, i64MinHeight))
++      return false;
++
++    int64_t i64XUpper = i64X + i64Width;
++    int64_t i64YUpper = i64Y + i64Height;
++
++    // Align X and Y to be on the grid with spacing MinWidth and MinHeight
++    int64_t r = (i64X % i64MinWidth);
++    i64X -= r;
++
++    r = (i64Y % i64MinHeight);
++    i64Y -= r;
++
++    // Align the upper coordinates (remove remainder and add one full spacing)
++    r = (i64XUpper % i64MinWidth);
++    if (r != 0)
++      i64XUpper += i64MinWidth - r;
++
++    r = (i64YUpper % i64MinHeight);
++    if (r != 0)
++      i64YUpper += i64MinHeight - r;
++
++    // Update width and height
++    i64Width = i64XUpper - i64X;
++    i64Height = i64YUpper - i64Y;
++
++    return true;
++  }
++
++private:
++  openslide_t *m_Osr;
++  int32_t      m_Level;
++  std::string  m_AssociatedImage;
++  bool         m_ApproximateStreaming;
++};
++
++OpenSlideImageIO::OpenSlideImageIO()
++{
++  using PixelType = RGBAPixel<unsigned char>;
++  PixelType clPixel;
++
++  m_OpenSlideWrapper = NULL;
++  m_OpenSlideWrapper = new OpenSlideWrapper();
++
++  this->SetNumberOfDimensions(2); // OpenSlide is 2D.
++  this->SetPixelTypeInfo(&clPixel);  
++
++  m_Spacing[0] = 1.0;
++  m_Spacing[1] = 1.0;
++
++  m_Origin[0] = 0.0;
++  m_Origin[1] = 0.0;
++
++  m_Dimensions[0] = 0;
++  m_Dimensions[1] = 0;
++
++  // Trestle, Aperio, Ventana, and generic tiled tiff
++  this->AddSupportedReadExtension(".tif");
++  // Hamamatsu
++  this->AddSupportedReadExtension(".vms");
++  this->AddSupportedReadExtension(".vmu");
++  this->AddSupportedReadExtension(".ndpi");
++  // Aperio
++  this->AddSupportedReadExtension(".svs");
++  // MIRAX
++  this->AddSupportedReadExtension(".mrxs");
++  // Leica
++  this->AddSupportedReadExtension(".scn");
++  // Philips
++  this->AddSupportedReadExtension(".tiff");
++  // Ventana
++  this->AddSupportedReadExtension(".bif");
++  // Sakura
++  this->AddSupportedReadExtension(".svslide");
++}
++
++OpenSlideImageIO::~OpenSlideImageIO()
++{
++  if (m_OpenSlideWrapper != NULL) {
++    delete m_OpenSlideWrapper;
++    m_OpenSlideWrapper = NULL;
++  }
++}
++
++void OpenSlideImageIO::PrintSelf(std::ostream& os, Indent indent) const {
++  Superclass::PrintSelf(os, indent);
++  os << indent << "Level: " << GetLevel() << '\n';
++  os << indent << "Associated Image: " << GetAssociatedImageName() << '\n';
++}
++
++bool OpenSlideImageIO::CanReadFile( const char* filename ) {
++  std::string fname(filename);
++  bool supportedExtension = false;
++  ArrayOfExtensionsType::const_iterator extIt;
++
++  for( extIt = this->GetSupportedReadExtensions().begin(); extIt != this->GetSupportedReadExtensions().end(); ++extIt) {
++    if( fname.rfind( *extIt ) != std::string::npos ) {
++      supportedExtension = true;
++    }
++  }
++  if( !supportedExtension ) {
++    return false;
++  }
++
++  return OpenSlideWrapper::CanReadFile(filename);
++}
++
++bool OpenSlideImageIO::CanStreamRead() {
++  return m_OpenSlideWrapper != NULL && m_OpenSlideWrapper->CanStreamRead();
++}
++
++void OpenSlideImageIO::ReadImageInformation() {
++  using PixelType = RGBAPixel<unsigned char>;
++  PixelType clPixel;
++
++  this->SetNumberOfDimensions(2);
++  this->SetPixelTypeInfo(&clPixel);
++
++  m_Dimensions[0] = 0;
++  m_Dimensions[1] = 0;
++
++  m_Spacing[0] = 1.0;
++  m_Spacing[1] = 1.0;
++
++  m_Origin[0] = 0.0;
++  m_Origin[1] = 0.0;
++
++  if (m_OpenSlideWrapper == NULL) {
++    itkExceptionMacro( "Error OpenSlideImageIO could not open file: "
++                       << this->GetFileName()
++                       << std::endl
++                       << "Reason: NULL OpenSlideWrapper pointer.");
++  }
++
++  if (!m_OpenSlideWrapper->Open(this->GetFileName())) {
++    itkExceptionMacro( "Error OpenSlideImageIO could not open file: "
++                       << this->GetFileName()
++                       << std::endl
++                       << "Reason: "
++                       << itksys::SystemTools::GetLastSystemError() );
++    // NOTE: OpenSlide needs to be opened to query API for errors. This is assumed to be related to a system error.
++  }
++
++
++  // This will fill in default values as needed (in case it fails)
++  m_OpenSlideWrapper->GetSpacing(m_Spacing[0], m_Spacing[1]);
++
++  {
++    int64_t i64Width = 0, i64Height = 0;
++    if (!m_OpenSlideWrapper->GetDimensions(i64Width, i64Height)) {
++      std::string strError = "Unknown";
++      const char * const p_cError = m_OpenSlideWrapper->GetError();
++
++      if (p_cError != NULL) {
++        strError = p_cError;
++        m_OpenSlideWrapper->Close(); // Can only safely close this now
++      }
++
++      itkExceptionMacro( "Error OpenSlideImageIO could not read dimensions: "
++                         << this->GetFileName()
++                         << std::endl
++                         << "Reason: " << strError );
++    }
++
++    // i64Width and i64Height are known to be positive
++    if ((uint64_t)i64Width > std::numeric_limits<SizeValueType>::max() || (uint64_t)i64Height > std::numeric_limits<SizeValueType>::max()) {
++      itkExceptionMacro( "Error OpenSlideImageIO image dimensions are too large for SizeValueType: "
++                         << this->GetFileName()
++                         << std::endl
++                         << "Reason: " 
++                         << i64Width << " > " << std::numeric_limits<SizeValueType>::max() 
++                         << " or " << i64Height << " > " << std::numeric_limits<SizeValueType>::max() );
++    }
++
++    m_Dimensions[0] = (SizeValueType)i64Width;
++    m_Dimensions[1] = (SizeValueType)i64Height;
++  }
++
++  this->SetMetaDataDictionary(m_OpenSlideWrapper->GetMetaDataDictionary());
++}
++
++
++void OpenSlideImageIO::Read( void * buffer)
++{
++  uint32_t * const p_u32Buffer = (uint32_t *)buffer;
++
++  if (m_OpenSlideWrapper == NULL || !m_OpenSlideWrapper->IsOpened()) {
++    itkExceptionMacro( "Error OpenSlideImageIO could not read region: "
++                       << this->GetFileName()
++                       << std::endl
++                       << "Reason: OpenSlide context is not opened." );
++  }
++
++  const ImageIORegion clRegionToRead = this->GetIORegion();
++  const ImageIORegion::SizeType clSize = clRegionToRead.GetSize();
++  const ImageIORegion::IndexType clStart = clRegionToRead.GetIndex();
++
++  if ( ((uint64_t)clSize[0])*((uint64_t)clSize[1]) > std::numeric_limits<ImageIORegion::SizeValueType>::max() ) {
++    itkExceptionMacro( "Error OpenSlideImageIO could not read region: "
++                       << this->GetFileName()
++                       << std::endl
++                       << "Reason: Requested region size in pixels overflows." );
++  }
++
++  const char *p_cError = m_OpenSlideWrapper->ReadRegion(p_u32Buffer, clStart[0], clStart[1], clSize[0], clSize[1]);
++
++  if (p_cError != NULL) {
++    std::string strError = p_cError; // Copy this since Close() may destroy the backing buffer
++    m_OpenSlideWrapper->Close(); // Can only safely close this now
++    itkExceptionMacro( "Error OpenSlideImageIO could not read region: "
++                       << this->GetFileName()
++                       << std::endl
++                       << "Reason: " << strError );
++  }
++
++  // Re-order the bytes (ARGB -> RGBA)
++  const int64_t i64TotalSize = clRegionToRead.GetNumberOfPixels();
++  for (int64_t i = 0; i < i64TotalSize; ++i) {
++    // XXX: Endianness?
++    RGBAPixel<unsigned char> clPixel;
++    clPixel.SetRed((p_u32Buffer[i] >> 16) & 0xff);
++    clPixel.SetGreen((p_u32Buffer[i] >> 8) & 0xff);
++    clPixel.SetBlue(p_u32Buffer[i] & 0xff);
++    clPixel.SetAlpha((p_u32Buffer[i] >> 24) & 0xff);
++
++    p_u32Buffer[i] = *reinterpret_cast<uint32_t *>(clPixel.GetDataPointer());
++  }
++}
++
++bool OpenSlideImageIO::CanWriteFile( const char * /*name*/ )
++{
++  return false;
++}
++
++void
++OpenSlideImageIO
++::WriteImageInformation(void) {
++  // add writing here
++}
++
++
++/**
++ *
++ */
++void
++OpenSlideImageIO::Write( const void* /*buffer*/) {
++}
++
++/** Given a requested region, determine what could be the region that we can
++ * read from the file. This is called the streamable region, which will be
++ * smaller than the LargestPossibleRegion and greater or equal to the
++RequestedRegion */
++ImageIORegion
++OpenSlideImageIO::GenerateStreamableReadRegionFromRequestedRegion( const ImageIORegion & requested ) const {
++  if (m_OpenSlideWrapper == NULL)
++    return requested;
++
++  ImageIORegion::SizeType clSize = requested.GetSize();
++  ImageIORegion::IndexType clStart = requested.GetIndex();
++
++  int64_t i64X = clStart[0];
++  int64_t i64Y = clStart[1];
++
++  int64_t i64Width = clSize[0];
++  int64_t i64Height = clSize[1];
++
++  if (!m_OpenSlideWrapper->AlignReadRegion(i64X, i64Y, i64Width, i64Height))
++    return requested;
++
++  clStart[0] = (SizeValueType)i64X;
++  clStart[1] = (SizeValueType)i64Y;
++
++  clSize[0] = (SizeValueType)i64Width;
++  clSize[1] = (SizeValueType)i64Height;
++
++  ImageIORegion clNewRegion(requested);
++
++  clNewRegion.SetSize(clSize);
++  clNewRegion.SetIndex(clStart);
++
++  return clNewRegion;
++}
++
++/** Get underlying OpenSlide library version */
++std::string OpenSlideImageIO::GetOpenSlideVersion() const {
++  const char * const p_cVersion = OpenSlideWrapper::GetVersion();
++  return p_cVersion != NULL ? std::string(p_cVersion) : std::string();
++}
++
++/** Detect the vendor of the current file. */
++std::string OpenSlideImageIO::GetVendor() const {
++  const char * const p_cVendor = OpenSlideWrapper::DetectVendor(this->GetFileName());
++  return p_cVendor != NULL ? std::string(p_cVendor) : std::string();
++}
++
++/** Sets the level to read. Level 0 (default) is the highest resolution level.
++ * This method overrides any previously selected associated image. 
++ * Call ReadImageInformation() again after calling this function. */
++void OpenSlideImageIO::SetLevel(int iLevel) {
++  if (m_OpenSlideWrapper == NULL)
++    return;
++
++  m_OpenSlideWrapper->SetLevel(iLevel);
++}
++
++/** Returns the currently selected level. */
++int OpenSlideImageIO::GetLevel() const {
++  if (m_OpenSlideWrapper == NULL)
++    return -1;
++
++  return m_OpenSlideWrapper->GetLevel();
++}
++
++/** Returns the number of available levels. */
++int OpenSlideImageIO::GetLevelCount() const {
++  if (m_OpenSlideWrapper == NULL)
++    return -1;
++
++  return m_OpenSlideWrapper->GetLevelCount();
++}
++
++/** Sets the associated image to extract.
++ * This method overrides any previously selected level.
++ * Call ReadImageInformation() again after calling this function. */
++void OpenSlideImageIO::SetAssociatedImageName(const std::string &strName) {
++  if (m_OpenSlideWrapper == NULL)
++    return;
++
++  m_OpenSlideWrapper->SetAssociatedImageName(strName);
++}
++
++/** Returns the currently selected associated image name (empty string if none). */
++std::string OpenSlideImageIO::GetAssociatedImageName() const {
++  if (m_OpenSlideWrapper == NULL)
++    return std::string();
++
++  return m_OpenSlideWrapper->GetAssociatedImageName();
++}
++
++/** Sets the best level to read for the given downsample factor.
++ * This method overrides any previously selected associated image. 
++ * Call ReadImageInformation() again after calling this function. */
++bool OpenSlideImageIO::SetLevelForDownsampleFactor(double dDownsampleFactor) {
++  if (m_OpenSlideWrapper == NULL)
++    return false;
++
++  return m_OpenSlideWrapper->SetBestLevelForDownsample(dDownsampleFactor);
++}
++
++/** Returns all associated image names stored in the file. */
++OpenSlideImageIO::AssociatedImageNameContainer OpenSlideImageIO::GetAssociatedImageNames() const {
++  if (m_OpenSlideWrapper == NULL)
++    return AssociatedImageNameContainer();
++
++  return m_OpenSlideWrapper->GetAssociatedImageNames();
++}
++
++/** Returns the absolute maximum number of streamable regions (tiles). */
++int64_t OpenSlideImageIO::ComputeMaximumNumberOfStreamableRegions() const {
++  if (m_OpenSlideWrapper == NULL)
++    return -1;
++
++  return m_OpenSlideWrapper->ComputeMaximumNumberOfStreamableRegions();
++}
++
++/** Returns the maximum number of streamable regions similar (but >=) to the given region. */
++int64_t OpenSlideImageIO::ComputeMaximumNumberOfStreamableRegions(const ImageIORegion &clRegion) const {
++  if (m_OpenSlideWrapper == NULL)
++    return -1;
++
++  ImageIORegion::IndexType clStart = clRegion.GetIndex();
++  ImageIORegion::SizeType clSize = clRegion.GetSize();
++
++  if (clStart.size() != 2 || clSize.size() != 2)
++    return -1;
++
++  return m_OpenSlideWrapper->ComputeMaximumNumberOfStreamableRegions(clStart[0], clStart[1], clSize[0], clSize[1]);
++}
++
++/** Returns the minimum streamable region. */
++ImageIORegion OpenSlideImageIO::GetMinimumStreamableRegion() const {
++  if (m_OpenSlideWrapper == NULL)
++    return ImageIORegion();
++
++  ImageIORegion clRegion;
++  ImageIORegion::SizeType clSize(2);
++  ImageIORegion::IndexType clIndex(2, 0);
++
++  int64_t i64Width = 0, i64Height = 0;
++  if (!m_OpenSlideWrapper->ComputeMinimumStreamableRegionSize(i64Width, i64Height))
++    return ImageIORegion();
++
++  // XXX: Could overflow
++  clSize[0] = (SizeValueType)i64Width;
++  clSize[1] = (SizeValueType)i64Height;
++
++  clRegion.SetIndex(clIndex);
++  clRegion.SetSize(clSize);
++
++  return clRegion;
++}
++
++/** Turn on/off approximate streaming. This only affects streaming level images other than level 0. */
++void OpenSlideImageIO::SetApproximateStreaming(bool bApproximateStreaming) {
++  if (m_OpenSlideWrapper != NULL)
++    m_OpenSlideWrapper->SetApproximateStreaming(bApproximateStreaming);
++}
++
++/** Returns weather approximate streaming is enabled or not. */
++bool OpenSlideImageIO::GetApproximateStreaming() const {
++  return m_OpenSlideWrapper != NULL && m_OpenSlideWrapper->GetApproximateStreaming();
++}
++
++} // end namespace itk
+diff --git a/Modules/IO/OpenSlide/src/itkOpenSlideImageIOFactory.cxx b/Modules/IO/OpenSlide/src/itkOpenSlideImageIOFactory.cxx
+new file mode 100644
+index 0000000..e3352d5
+--- /dev/null
++++ b/Modules/IO/OpenSlide/src/itkOpenSlideImageIOFactory.cxx
+@@ -0,0 +1,65 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++#include "itkOpenSlideImageIOFactory.h"
++#include "itkCreateObjectFunction.h"
++#include "itkOpenSlideImageIO.h"
++#include "itkVersion.h"
++#include "ITKIOOpenSlideExport.h"
++
++namespace itk
++{
++OpenSlideImageIOFactory::OpenSlideImageIOFactory()
++{
++  this->RegisterOverride("itkImageIOBase",
++                         "itkOpenSlideImageIO",
++                         "OpenSlide Image IO",
++                         1,
++                         CreateObjectFunction<OpenSlideImageIO>::New());
++}
++
++OpenSlideImageIOFactory::~OpenSlideImageIOFactory()
++{
++}
++
++const char*
++OpenSlideImageIOFactory::GetITKSourceVersion() const
++{
++  return ITK_SOURCE_VERSION;
++}
++
++const char*
++OpenSlideImageIOFactory::GetDescription() const
++{
++  return "OpenSlide ImageIO Factory, allows the loading of OpenSlide images into insight";
++}
++
++// Undocumented API used to register during static initialization.
++// DO NOT CALL DIRECTLY.
++
++static bool OpenSlideImageIOFactoryHasBeenRegistered;
++
++void ITKIOOpenSlide_EXPORT OpenSlideImageIOFactoryRegister__Private(void)
++{
++  if( ! OpenSlideImageIOFactoryHasBeenRegistered )
++    {
++    OpenSlideImageIOFactoryHasBeenRegistered = true;
++    OpenSlideImageIOFactory::RegisterOneFactory();
++    }
++}
++
++} // end namespace itk
+diff --git a/Modules/IO/OpenSlide/test/CMakeLists.txt b/Modules/IO/OpenSlide/test/CMakeLists.txt
+new file mode 100644
+index 0000000..0a380d9
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/CMakeLists.txt
+@@ -0,0 +1,50 @@
++itk_module_test()
++set(ITKIOOpenSlideTests
++  itkOpenSlideImageIOTest.cxx
++  itkOpenSlideTestMetaData.cxx
++  )
++
++CreateTestDriver(ITKIOOpenSlide  "${IOOpenSlide-Test_LIBRARIES}" "${IOOpenSlideTests}")
++
++itk_add_test(NAME itkOpenSlideTestMetaData
++  COMMAND ITKIOOpenSlideTestDriver
++  itkOpenSlideTestMetaData DATA{Input/CMU-1.svs} ${ITK_TEST_OUTPUT_DIR}/MetaDataTest.txt DATA{Input/CMU-1.svs.txt}
++)
++
++itk_add_test(NAME itkOpenSlideTestBasicIO
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-1-Small-Region.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-1-Small-Region.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-1-Small-Region.svs} ${ITK_TEST_OUTPUT_DIR}/CMU-1-Small-Region.mha compress
++)
++
++itk_add_test(NAME itkOpenSlideTestAssociatedImage
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-1-Small-Region-label.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-1-Small-Region-label.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-1-Small-Region.svs} ${ITK_TEST_OUTPUT_DIR}/CMU-1-Small-Region-label.mha associatedImage=label compress
++)
++
++itk_add_test(NAME itkOpenSlideTestLevel
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-3-level-7.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-3-level-7.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-3.ndpi} ${ITK_TEST_OUTPUT_DIR}/CMU-3-level-7.mha level=7 compress
++)
++
++itk_add_test(NAME itkOpenSlideTestDownsample
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-3-level-7.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-3-downsample-129.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-3.ndpi} ${ITK_TEST_OUTPUT_DIR}/CMU-3-downsample-129.mha downsample=129 compress
++)
++
++# Compress cannot be used here since stream writing will not be supported
++itk_add_test(NAME itkOpenSlideTestApproximateStreaming
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-1-level-1-stream-200.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-1-level-1-stream-200.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-1.svs} ${ITK_TEST_OUTPUT_DIR}/CMU-1-level-1-stream-200.mha level=1 stream=200 approximateStreaming
++)
++
++itk_add_test(NAME itkOpenSlideTestStreaming
++  COMMAND ITKIOOpenSlideTestDriver
++  --compare DATA{Input/CMU-1-level-1.mha} ${ITK_TEST_OUTPUT_DIR}/CMU-1-level-1.mha
++  itkOpenSlideImageIOTest DATA{Input/CMU-1.svs} ${ITK_TEST_OUTPUT_DIR}/CMU-1-level-1.mha level=1 stream=200
++)
++
+diff --git a/Modules/IO/OpenSlide/test/Docker/Dockerfile b/Modules/IO/OpenSlide/test/Docker/Dockerfile
+new file mode 100644
+index 0000000..4df438a
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Docker/Dockerfile
+@@ -0,0 +1,48 @@
++FROM debian:8
++MAINTAINER Insight Software Consortium <community@itk.org>
++
++RUN apt-get update && apt-get install -y \
++  build-essential \
++  curl \
++  cmake \
++  git \
++  libexpat1-dev \
++  libhdf5-dev \
++  libjpeg-dev \
++  libopenslide-dev \
++  libpng12-dev \
++  libpython3-dev \
++  libtiff5-dev \
++  openslide-tools \
++  python \
++  ninja-build \
++  wget \
++  vim \
++  zlib1g-dev
++
++RUN mkdir -p /usr/src/ITKOpenSlideIO-build
++WORKDIR /usr/src
++
++# 2016-04-14
++ENV ITK_GIT_TAG 141bf9929f73b3f928ea022ed670959e81d036ff
++RUN git clone git://itk.org/ITK.git && \
++  cd ITK && \
++  git checkout ${ITK_GIT_TAG} && \
++  cd ../ && \
++  mkdir ITK-build && \
++  cd ITK-build && \
++  cmake \
++    -G Ninja \
++    -DCMAKE_INSTALL_PREFIX:PATH=/usr \
++    -DBUILD_EXAMPLES:BOOL=OFF \
++    -DBUILD_TESTING:BOOL=OFF \
++    -DBUILD_SHARED_LIBS:BOOL=ON \
++    -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=ON \
++    -DITK_LEGACY_REMOVE:BOOL=ON \
++    -DITK_BUILD_DEFAULT_MODULES:BOOL=OFF \
++    -DITK_USE_SYSTEM_LIBRARIES:BOOL=ON \
++    -DModule_ITKIOImageBase:BOOL=ON \
++    -DModule_ITKTestKernel:BOOL=ON \
++    ../ITK && \
++  ninja && \
++  find . -name '*.o' -delete
+diff --git a/Modules/IO/OpenSlide/test/Docker/build.sh b/Modules/IO/OpenSlide/test/Docker/build.sh
+new file mode 100644
+index 0000000..ede6179
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Docker/build.sh
+@@ -0,0 +1,5 @@
++#!/bin/sh
++
++script_dir="`cd $(dirname $0); pwd`"
++
++docker build -t insighttoolkit/openslideio-test $script_dir
+diff --git a/Modules/IO/OpenSlide/test/Docker/run.sh b/Modules/IO/OpenSlide/test/Docker/run.sh
+new file mode 100644
+index 0000000..fc221c2
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Docker/run.sh
+@@ -0,0 +1,9 @@
++#!/bin/sh
++
++script_dir="`cd $(dirname $0); pwd`"
++
++docker run \
++  --rm \
++  -v $script_dir/../..:/usr/src/ITKOpenSlideIO \
++    insighttoolkit/openslideio-test \
++      /usr/src/ITKOpenSlideIO/test/Docker/test.sh
+diff --git a/Modules/IO/OpenSlide/test/Docker/test.sh b/Modules/IO/OpenSlide/test/Docker/test.sh
+new file mode 100644
+index 0000000..201daee
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Docker/test.sh
+@@ -0,0 +1,27 @@
++#!/bin/bash
++
++# This is a script to build the modules and run the test suite in the base
++# Docker container.
++
++set -x
++set -e
++
++cd /usr/src/ITKOpenSlideIO-build
++
++cmake \
++  -G Ninja \
++  -DITK_DIR:PATH=/usr/src/ITK-build \
++  -DBUILD_TESTING:BOOL=ON \
++  -DCMAKE_BUILD_TYPE:STRING=Release \
++  -DBUILDNAME:STRING=External-OpenSlideIO \
++    /usr/src/ITKOpenSlideIO
++ctest -VV -D Experimental
++
++mkdir -p /usr/src/ITKOpenSlideIO-example-build
++cd /usr/src/ITKOpenSlideIO-example-build
++cmake \
++  -G Ninja \
++  -DITK_DIR:PATH=/usr/src/ITK-build \
++  -DCMAKE_BUILD_TYPE:STRING=Release \
++    /usr/src/ITKOpenSlideIO/examples/
++ninja
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region-label.mha.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region-label.mha.md5
+new file mode 100644
+index 0000000..b3b1564
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region-label.mha.md5
+@@ -0,0 +1 @@
++c58b6b28c928dbb6dccd90c5816a4fd9
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.mha.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.mha.md5
+new file mode 100644
+index 0000000..7d22078
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.mha.md5
+@@ -0,0 +1 @@
++500ac47f67c06d2f9659057290852481
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.svs.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.svs.md5
+new file mode 100644
+index 0000000..da82f01
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1-Small-Region.svs.md5
+@@ -0,0 +1 @@
++1ad6e35c9d17e4d85fb7e3143b328efe
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1-level-1-stream-200.mha.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1-level-1-stream-200.mha.md5
+new file mode 100644
+index 0000000..9fbac1d
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1-level-1-stream-200.mha.md5
+@@ -0,0 +1 @@
++4d073b911c27e3b1ae82aa1e5c15bb98
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1-level-1.mha.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1-level-1.mha.md5
+new file mode 100644
+index 0000000..5f41150
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1-level-1.mha.md5
+@@ -0,0 +1 @@
++dcbbbbebed96b976afcd78d498ff4dcd
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1.svs.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1.svs.md5
+new file mode 100644
+index 0000000..f73cecf
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1.svs.md5
+@@ -0,0 +1 @@
++751b0b86a3c5ff4dfc8567cf24daaa85
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-1.svs.txt.md5 b/Modules/IO/OpenSlide/test/Input/CMU-1.svs.txt.md5
+new file mode 100644
+index 0000000..4bbde65
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-1.svs.txt.md5
+@@ -0,0 +1 @@
++e049db8747ced4f382afed3456e40f43
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-3-level-7.mha.md5 b/Modules/IO/OpenSlide/test/Input/CMU-3-level-7.mha.md5
+new file mode 100644
+index 0000000..b3610cb
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-3-level-7.mha.md5
+@@ -0,0 +1 @@
++561364e6235ec46ebaa4488091c8cf44
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/Input/CMU-3.ndpi.md5 b/Modules/IO/OpenSlide/test/Input/CMU-3.ndpi.md5
+new file mode 100644
+index 0000000..297d5f2
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/Input/CMU-3.ndpi.md5
+@@ -0,0 +1 @@
++86bed2d21e61b7062c9a8aecba077f6d
+\ No newline at end of file
+diff --git a/Modules/IO/OpenSlide/test/itkOpenSlideImageIOTest.cxx b/Modules/IO/OpenSlide/test/itkOpenSlideImageIOTest.cxx
+new file mode 100644
+index 0000000..5ed0019
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/itkOpenSlideImageIOTest.cxx
+@@ -0,0 +1,268 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++
++#include <cstdlib>
++#include <cstring>
++
++#include "itkOpenSlideImageIO.h"
++#include "itkOpenSlideImageIOFactory.h"
++
++#include "itkImageIOFactory.h"
++#include "itkImageFileReader.h"
++#include "itkImageFileWriter.h"
++#include "itkImage.h"
++#include "itkRGBAPixel.h"
++#include "itkOpenSlideImageIO.h"
++
++#define SPECIFIC_IMAGEIO_MODULE_TEST
++
++namespace {
++
++bool ParseValue(const char *p_cValue, std::string &strCommand, std::string &strValue) {
++  strCommand.clear();
++  strValue.clear();
++
++  if (p_cValue == NULL)
++    return false;
++
++  const char *p = strchr(p_cValue, '=');
++
++  if (p == NULL) {
++    strCommand = p_cValue;
++    return true;
++  }
++
++  // is p the beginning or end of the string?
++  if (p == p_cValue)
++    return false;
++
++  strCommand.assign(p_cValue, (p-p_cValue));
++  strValue = p+1;
++
++  return true;
++}
++
++#if 0
++// For generating data for tests (particularly the streaming one)
++bool CompressImageFile(const char *p_cFileName) {
++  using PixelType = itk::RGBAPixel<unsigned char>;
++  using ImageType = itk::Image<PixelType, 2>;
++
++  using ReaderType = itk::ImageFileReader<ImageType>;
++  using WriterType = itk::ImageFileWriter<ImageType>;
++
++  ReaderType::Pointer p_clReader = ReaderType::New();
++  WriterType::Pointer p_clWriter = WriterType::New();
++
++  p_clReader->SetFileName(p_cFileName);
++  p_clWriter->SetInput(p_clReader->GetOutput());
++  p_clWriter->SetFileName(p_cFileName);
++  p_clWriter->UseCompressionOn();
++
++  try {
++    p_clWriter->Update();
++  }
++  catch (itk::ExceptionObject &e) {
++    std::cerr << "Error: " << e << std::endl;
++    return false;
++  }
++
++  return true;
++}
++#endif
++
++} // End anonymous namespace
++
++int itkOpenSlideImageIOTest( int argc, char * argv[] ) {
++  using PixelType = itk::RGBAPixel<unsigned char>;
++  using ImageType = itk::Image<PixelType, 2>;
++  using ReaderIOType = itk::OpenSlideImageIO;
++  using ReaderType = itk::ImageFileReader<ImageType>;
++  using WriterType = itk::ImageFileWriter<ImageType>;
++
++  if( argc < 3 ) {
++    std::cerr << "Usage: " << argv[0] << " inputImage outputImage [command1 command2 ...]\n";
++    return EXIT_FAILURE;
++  }
++
++  //const char * const p_cArg0 = argv[0];
++  const char * const p_cInputImage = argv[1];
++  const char * const p_cOutputImage = argv[2];
++
++  argc -= 3;
++  argv += 3;
++
++  bool bShouldFail = false;
++  bool bUseCompression = false;
++  bool bApproximateStreaming = false;
++  unsigned int uiNumStreams = 0; // 0 means no streaming
++  int iLevel = 0;
++  std::string strAssociatedImageName;
++  double dDownsampleFactor = 0.0; // 0 means no down sample
++
++  for (int i = 0; i < argc; ++i) {
++    std::string strCommand;
++    std::string strValue;
++
++    if (!ParseValue(argv[i], strCommand, strValue)) {
++      std::cerr << "Error: Could not parse value '" << argv[i] << "'." << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    if (strCommand == "shouldFail") {
++      bShouldFail = true;
++    }
++    else if (strCommand == "compress") {
++      bUseCompression = true;
++    }
++    else if (strCommand == "approximateStreaming") {
++      bApproximateStreaming = true;
++    }
++    else if (strCommand == "level") {
++      if (strValue.empty()) {
++        std::cerr << "Error: Expected level parameter." << std::endl;
++        return EXIT_FAILURE;
++      }
++
++      char *p = NULL;
++      iLevel = strtol(strValue.c_str(), &p, 10);
++      if (*p != '\0') {
++        std::cerr << "Error: Could not parse level '" << strValue << "'." << std::endl;
++        return EXIT_FAILURE;
++      }
++    }
++    else if (strCommand == "associatedImage") {
++      if (strValue.empty()) {
++        std::cerr << "Error: Expected associated image name." << std::endl;
++        return EXIT_FAILURE;
++      }
++
++      strAssociatedImageName = strValue;
++    }
++    else if (strCommand == "downsample") {
++      if (strValue.empty()) {
++        std::cerr << "Error: Expected downsample factor." << std::endl;
++        return EXIT_FAILURE;
++      }
++
++      char *p = NULL;
++      dDownsampleFactor = strtod(strValue.c_str(), &p);
++      if (*p != '\0') {
++        std::cerr << "Error: Could not parse downsample factor '" << strValue << "'." << std::endl;
++        return EXIT_FAILURE;
++      }
++    }
++    else if (strCommand == "stream") {
++      if (strValue.empty()) {
++        std::cerr << "Error: Expected number of streams." << std::endl;
++        return EXIT_FAILURE;
++      }
++
++      char *p = NULL;
++      uiNumStreams = strtoul(strValue.c_str(), &p, 10);
++      if (*p != '\0') {
++        std::cerr << "Error: Could not parse number of streams '" << strValue << "'." << std::endl;
++        return EXIT_FAILURE;
++      }
++    }
++    else {
++      std::cout << "Error: Unknown command '" << argv[i] << "'." << std::endl;
++      return EXIT_FAILURE;
++    }
++  }
++
++  const int iFailCode = (bShouldFail ? EXIT_SUCCESS : EXIT_FAILURE);
++  const int iSuccessCode = (iFailCode == EXIT_FAILURE ? EXIT_SUCCESS : EXIT_FAILURE);
++
++  std::cout << "Parameters:\n" << std::endl;
++  std::cout << "inputImage = '" << p_cInputImage << '\'' << std::endl;
++  std::cout << "outputImage = '" << p_cOutputImage << '\'' << std::endl;
++  std::cout << "shouldFail = " << std::boolalpha << bShouldFail << std::endl;
++  std::cout << "compress = " << std::boolalpha << bUseCompression << std::endl;
++  std::cout << "approximateStreaming = " << std::boolalpha << bApproximateStreaming << std::endl;
++  std::cout << "stream = " << uiNumStreams << std::endl;
++  std::cout << "level = " << iLevel << std::endl;
++  std::cout << "associatedImage = '" << strAssociatedImageName << '\'' << std::endl;
++  std::cout << "downsample = " << dDownsampleFactor << std::endl;
++
++  ReaderIOType::Pointer p_clImageIO = ReaderIOType::New();
++  ReaderType::Pointer p_clReader = ReaderType::New();
++  WriterType::Pointer p_clWriter = WriterType::New();
++
++  p_clImageIO->SetFileName(p_cInputImage);
++
++  p_clReader->SetImageIO(p_clImageIO);
++  p_clReader->SetFileName(p_cInputImage);
++
++  p_clWriter->SetInput(p_clReader->GetOutput());
++  p_clWriter->SetFileName(p_cOutputImage);
++
++  try {
++    p_clImageIO->ReadImageInformation();
++  }
++  catch (itk::ExceptionObject &e) {
++    std::cerr << "Error: " << e << std::endl;
++    return iFailCode;
++  }
++
++  if (strAssociatedImageName.size() > 0)
++    p_clImageIO->SetAssociatedImageName(strAssociatedImageName);
++  else
++    p_clImageIO->SetLevel(iLevel);
++
++  if (dDownsampleFactor > 0.0 && !p_clImageIO->SetLevelForDownsampleFactor(dDownsampleFactor))
++    return iFailCode;
++
++  if (uiNumStreams > 0) {
++    if (!p_clImageIO->CanStreamRead())
++      return iFailCode;
++
++    p_clImageIO->UseStreamedReadingOn();
++    p_clImageIO->SetApproximateStreaming(bApproximateStreaming);
++
++    itk::ImageIOBase::Pointer p_clWriterIO = itk::ImageIOFactory::CreateImageIO(p_cOutputImage, itk::IOFileModeEnum::WriteMode);
++    if (!p_clWriterIO) {
++      std::cerr << "Error: Could not create ImageIO for output image '" << p_cOutputImage << "'." << std::endl;
++      return iFailCode;
++    }
++
++    if (bUseCompression)
++      std::cout << "Warning: Compression may disable streaming." << std::endl;
++
++    p_clWriterIO->UseStreamedWritingOn();
++
++    p_clWriter->SetImageIO(p_clWriterIO);
++    p_clWriter->SetNumberOfStreamDivisions(uiNumStreams);
++  }
++
++  // XXX: Just so you know, this might disable streaming
++  p_clWriter->SetUseCompression(bUseCompression);
++
++  try {
++    p_clWriter->Update();
++  }
++  catch (itk::ExceptionObject &e) {
++    std::cerr << "Error: " << e << std::endl;
++    return iFailCode;
++  }
++
++  // Use this to compress output images when updating tests
++  //CompressImageFile(p_cOutputImage);
++
++  return iSuccessCode;
++}
+diff --git a/Modules/IO/OpenSlide/test/itkOpenSlideTestMetaData.cxx b/Modules/IO/OpenSlide/test/itkOpenSlideTestMetaData.cxx
+new file mode 100644
+index 0000000..ce46f08
+--- /dev/null
++++ b/Modules/IO/OpenSlide/test/itkOpenSlideTestMetaData.cxx
+@@ -0,0 +1,282 @@
++/*=========================================================================
++ *
++ *  Copyright NumFOCUS
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *         http://www.apache.org/licenses/LICENSE-2.0.txt
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *=========================================================================*/
++
++#include <cstring>
++#include <algorithm>
++#include <iostream>
++#include <fstream>
++#include <vector>
++#include "itkOpenSlideImageIO.h"
++#include "itkOpenSlideImageIOFactory.h"
++#include "itkImage.h"
++#include "itkMetaDataObject.h"
++
++#define SPECIFIC_IMAGEIO_MODULE_TEST
++
++namespace {
++
++class ReplaceStream {
++public:
++  ReplaceStream(std::ios &stream, const std::ios &newStream)
++  : m_Stream(stream), m_OriginalBuf(stream.rdbuf(newStream.rdbuf())) { }
++
++  ~ReplaceStream() {
++    m_Stream.rdbuf(m_OriginalBuf);
++  }
++
++private:
++  std::ios               &m_Stream;
++  std::streambuf * const m_OriginalBuf;
++};
++
++bool ReadFileStripCR(const char *p_cFileName, std::vector<char> &vBuffer) {
++  vBuffer.clear();
++
++  std::ifstream fileStream(p_cFileName);
++  if (!fileStream)
++    return false;
++
++  fileStream.seekg(0, std::ifstream::end);
++  const size_t length = fileStream.tellg();
++  fileStream.seekg(0, std::ifstream::beg);
++
++  vBuffer.resize(length);
++
++  if (!fileStream.read(&vBuffer[0], vBuffer.size()))
++    return false;
++
++  size_t j = 0;
++  for (size_t i = 0; i < vBuffer.size(); ++i) {
++    if (vBuffer[i] != '\r') {
++      vBuffer[j] = vBuffer[i];
++      ++j;
++    }
++  }
++
++  vBuffer.resize(j);
++
++  return true;
++}
++
++} // End anonymous namespace
++
++int itkOpenSlideTestMetaData( int argc, char * argv[] ) {
++  using ImageIOType = itk::OpenSlideImageIO;
++  using PixelType = itk::RGBAPixel<unsigned char>;
++  using ImageType = itk::Image<PixelType, 2>;
++  using SizeType = ImageType::SizeType;
++  using SpacingType = ImageType::SpacingType;
++
++  if (argc < 2 || argc > 4) {
++    std::cerr << "Usage: " << argv[0] << " slideFile [outputLog] [comparisonLog]" << std::endl;
++    return EXIT_FAILURE;
++  }
++
++  const char * const p_cSlideFile = argv[1];
++  const char * const p_cOutputLog = argc > 2 ? argv[2] : "stdout";
++  const char * const p_cCompareLog = argc > 3 ? argv[3] : NULL;
++
++  std::ofstream logFileStream;
++  std::ostream *p_outStream = &std::cout;
++
++  if (strcmp(p_cOutputLog, "stdout") != 0) {
++    logFileStream.open(p_cOutputLog, std::ofstream::out | std::ofstream::trunc);
++    if (!logFileStream) {
++      std::cerr << "Error: Could not open output log '" << p_cOutputLog << "'." << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    p_outStream = &logFileStream;
++  }
++
++  // RAII trick
++  ReplaceStream clStreamGuard(std::cout, *p_outStream);
++
++  ImageIOType::Pointer p_clImageIO = ImageIOType::New();
++
++  p_clImageIO->SetFileName(p_cSlideFile);
++
++  try {
++    p_clImageIO->ReadImageInformation();
++  }
++  catch (itk::ExceptionObject &e) {
++    std::cerr << "Error: " << e << std::endl;
++    return EXIT_FAILURE;
++  }
++
++  const std::string strComponentType = itk::ImageIOBase::GetComponentTypeAsString(p_clImageIO->GetComponentType()); 
++  const std::string strPixelType = itk::ImageIOBase::GetPixelTypeAsString(p_clImageIO->GetPixelType());
++
++  std::cout << "\nImage Information:\n" << std::endl;
++  std::cout << "Dimensions: " << p_clImageIO->GetNumberOfDimensions() << std::endl;
++  std::cout << "Component type: " << strComponentType << std::endl;
++  std::cout << "Pixel type: " << strPixelType << std::endl;
++  std::cout << "Vendor: " << p_clImageIO->GetVendor() << std::endl;
++
++  // Some sanity checks
++
++  // Check dimensions
++  if (p_clImageIO->GetNumberOfDimensions() != ImageType::GetImageDimension()) {
++    std::cerr << "Error: ImageIO should report dimension " << ImageType::GetImageDimension() << " but reports " << p_clImageIO->GetNumberOfDimensions() << '.' << std::endl;
++    return EXIT_FAILURE;
++  }
++
++  // Check pixel type
++  {
++    // Let's use an ImageIOType to form the expected pixel information
++    ImageIOType::Pointer p_clTmpIO = ImageIOType::New();
++
++    PixelType clTmpPixel;
++    p_clTmpIO->SetPixelTypeInfo(&clTmpPixel);
++
++    const std::string strExpectedComponentType = itk::ImageIOBase::GetComponentTypeAsString(p_clTmpIO->GetComponentType());
++    const std::string strExpectedPixelType = itk::ImageIOBase::GetPixelTypeAsString(p_clTmpIO->GetPixelType());
++
++    if (strExpectedComponentType != strComponentType) {
++      std::cerr << "Error: ImageIO should report a component type of " << strExpectedComponentType << " but reports " << strComponentType << '.' << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    if (strExpectedPixelType != strPixelType) {
++      std::cerr << "Error: ImageIO should report a pixel type of " << strExpectedPixelType << " but reports " << strPixelType << '.' << std::endl;
++      return EXIT_FAILURE;
++    }
++  }
++    
++  // Sanity checks passed
++
++  std::cout << "\nMeta Data:\n" << std::endl;
++
++  itk::MetaDataDictionary &clTags = p_clImageIO->GetMetaDataDictionary();
++  std::vector<std::string> vKeys = clTags.GetKeys();
++
++  std::cout << "Number of keys: " << vKeys.size() << std::endl;
++  std::cout << "Entries:" << std::endl;
++  for (size_t i = 0; i < vKeys.size(); ++i) {
++    const std::string &strKey = vKeys[i];
++    std::string strValue;
++
++    if (itk::ExposeMetaData(clTags, strKey, strValue))
++      std::cout << strKey << " = " << strValue << std::endl;
++  }
++
++  std::cout << "\nLevel Information:\n" << std::endl;
++
++  const int iLevelCount = p_clImageIO->GetLevelCount();
++  std::cout << "Level count: " << iLevelCount << std::endl;
++
++  std::cout << "Levels:" << std::endl;
++  for (int iLevel = 0; iLevel < iLevelCount; ++iLevel) {
++    p_clImageIO->SetLevel(iLevel);
++
++    try {
++      p_clImageIO->ReadImageInformation();
++    }
++    catch (itk::ExceptionObject &e) {
++      std::cerr << "Error: " << e << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    SizeType clSize;
++    clSize[0] = p_clImageIO->GetDimensions(0);
++    clSize[1] = p_clImageIO->GetDimensions(1);
++
++    SpacingType clSpacing;
++    clSpacing[0] = p_clImageIO->GetSpacing(0);
++    clSpacing[1] = p_clImageIO->GetSpacing(1);
++
++    const size_t sizeInBytes = p_clImageIO->GetImageSizeInBytes();
++    const int iCurrentLevel = p_clImageIO->GetLevel();
++
++    std::cout << "Level " << iCurrentLevel << ": dimensions = " << clSize << ", spacing = " << clSpacing << ", size in bytes = " << sizeInBytes << std::endl;
++  }
++
++  std::cout << "\nAssociated image information:\n" << std::endl;
++
++  ImageIOType::AssociatedImageNameContainer vAssociatedImages = p_clImageIO->GetAssociatedImageNames();
++
++  std::cout << "Number of associated images: " << vAssociatedImages.size() << std::endl;
++  std::cout << "Associated image names:" << std::endl;
++
++  const size_t numWordsPerLine = 3;
++
++  for (size_t i = 0; i < vAssociatedImages.size(); i += numWordsPerLine) {
++    const size_t jBegin = i;
++    const size_t jEnd = std::min(vAssociatedImages.size(), jBegin + numWordsPerLine);
++
++    std::cout << '\'' << vAssociatedImages[jBegin] << '\'';
++
++    for (size_t j = jBegin+1; j < jEnd; ++j)
++      std::cout << ", '" << vAssociatedImages[j] << '\'';
++
++    if (i + numWordsPerLine < vAssociatedImages.size())
++      std::cout << ',';
++
++    std::cout << std::endl;
++  }
++
++  std::cout << "\nAssociated images:" << std::endl;
++
++  for (size_t i = 0; i < vAssociatedImages.size(); ++i) {
++    const std::string &strAssociatedImage = vAssociatedImages[i];
++
++    p_clImageIO->SetAssociatedImageName(strAssociatedImage);
++
++    try {
++      p_clImageIO->ReadImageInformation();
++    }
++    catch (itk::ExceptionObject &e) {
++      std::cerr << "Error: " << e << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    SizeType clSize;
++    clSize[0] = p_clImageIO->GetDimensions(0);
++    clSize[1] = p_clImageIO->GetDimensions(1);
++
++    SpacingType clSpacing;
++    clSpacing[0] = p_clImageIO->GetSpacing(0);
++    clSpacing[1] = p_clImageIO->GetSpacing(1);
++
++    const size_t sizeInBytes = p_clImageIO->GetImageSizeInBytes();
++    const std::string strCurrentAssociatedImage = p_clImageIO->GetAssociatedImageName();
++
++    std::cout << strCurrentAssociatedImage << ": dimensions = " << clSize << ", spacing = " << clSpacing << ", size in bytes = " << sizeInBytes << std::endl;
++  }
++
++  if (p_cCompareLog != NULL) {
++    logFileStream.close();
++
++    std::vector<char> vBuffer1, vBuffer2;
++
++    if (!ReadFileStripCR(p_cOutputLog, vBuffer1)) {
++      std::cerr << "Error: Could not read output log file '" << p_cOutputLog << "'." << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    if (!ReadFileStripCR(p_cCompareLog, vBuffer2)) {
++      std::cerr << "Error: Could not read comparison log file '" << p_cCompareLog << "'." << std::endl;
++      return EXIT_FAILURE;
++    }
++
++    if (vBuffer1.size() != vBuffer2.size() || std::memcmp(&vBuffer1[0], &vBuffer2[0], vBuffer1.size()) != 0)
++      return EXIT_FAILURE;
++  }
++
++  return EXIT_SUCCESS;
++}
diff --git a/CMakeExternals/ITK.cmake b/CMakeExternals/ITK.cmake
index 973e57229d..95f7e364f5 100644
--- a/CMakeExternals/ITK.cmake
+++ b/CMakeExternals/ITK.cmake
@@ -53,7 +53,7 @@ if(NOT DEFINED ITK_DIR)
      URL ${MITK_THIRDPARTY_DOWNLOAD_PREFIX_URL}/InsightToolkit-4.13.3.tar.gz
      URL_MD5 d1c10c8288b47577d718a71190444815
      PATCH_COMMAND
-       ${PATCH_COMMAND} -N -p1 -i ${CMAKE_CURRENT_LIST_DIR}/ITK-4.13.3.patch
+       ${PATCH_COMMAND} -N -p1 -i ${CMAKE_CURRENT_LIST_DIR}/ITK-4.13.3_OpenSlide.patch
      CMAKE_GENERATOR ${gen}
      CMAKE_GENERATOR_PLATFORM ${gen_platform}
      CMAKE_ARGS
diff --git a/Modules/Annotation/include/mitkColorBarAnnotation.h b/Modules/Annotation/include/mitkColorBarAnnotation.h
index d70f925819..5244f629c2 100644
--- a/Modules/Annotation/include/mitkColorBarAnnotation.h
+++ b/Modules/Annotation/include/mitkColorBarAnnotation.h
@@ -46,7 +46,7 @@ namespace mitk
     itkFactorylessNewMacro(Self);
     itkCloneMacro(Self);
 
-      void SetDrawAnnotations(bool annotations);
+    void SetDrawAnnotations(bool annotations);
     bool GetDrawAnnotations() const;
 
     void SetOrientationToHorizontal();
@@ -69,6 +69,14 @@ namespace mitk
     void SetAnnotationTextScaling(bool scale);
     bool GetAnnotationTextScaling() const;
 
+    void SetFontSize(int s);
+    int GetFontSize() const;
+
+    int GetWidth() const;
+    void SetWidth(int s);
+
+    void SetLength(int s);
+    int GetLenght() const;
   protected:
     /** \brief The LocalStorageHandler holds all LocalStorages for the render windows. */
     mutable mitk::LocalStorageHandler<LocalStorage> m_LSH;
@@ -79,6 +87,8 @@ namespace mitk
     /** \brief explicit constructor which disallows implicit conversions */
     explicit ColorBarAnnotation();
 
+    void Update(mitk::BaseRenderer *renderer) override;
+
     /** \brief virtual destructor in order to derive from this class */
     ~ColorBarAnnotation() override;
 
diff --git a/Modules/Annotation/src/mitkColorBarAnnotation.cpp b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
index 31ee59f04b..40e9aa33da 100644
--- a/Modules/Annotation/src/mitkColorBarAnnotation.cpp
+++ b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
@@ -14,19 +14,24 @@ found in the LICENSE file.
 #include "mitkLookupTable.h"
 #include "mitkLookupTableProperty.h"
 #include <vtkScalarBarActor.h>
+#include <vtkTextProperty.h>
+#include <vtkProperty2D.h>
 
 mitk::ColorBarAnnotation::ColorBarAnnotation()
 {
   SetDrawAnnotations(true);
-
   SetDrawTickLabels(true);
 
   SetOrientationToVertical();
-
   SetMaxNumberOfColors(100);
   SetNumberOfLabels(4);
 
   SetAnnotationTextScaling(false);
+  SetFontSize(8);
+  SetLength(200);
+
+  SetWidth(50);
+  SetColor(0.0, 0.0, 0.0);
 
   SetLookupTable(nullptr);
 }
@@ -42,13 +47,61 @@ mitk::ColorBarAnnotation::~ColorBarAnnotation()
   }
 }
 
-mitk::ColorBarAnnotation::LocalStorage::~LocalStorage()
+mitk::ColorBarAnnotation::LocalStorage::~LocalStorage() {}
+
+void mitk::ColorBarAnnotation::SetFontSize(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Fontsize", s);
+}
+
+int mitk::ColorBarAnnotation::GetFontSize() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Fontsize", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetWidth(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Width", s);
+}
+
+int mitk::ColorBarAnnotation::GetWidth() const
 {
+  int val;
+  GetIntProperty("ColorBarAnnotation.Width", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetLength(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Length", s);
+}
+
+int mitk::ColorBarAnnotation::GetLenght() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Length", val);
+  return val;
 }
 
 mitk::ColorBarAnnotation::LocalStorage::LocalStorage()
 {
   m_ScalarBarActor = vtkSmartPointer<vtkScalarBarActor>::New();
+  m_ScalarBarActor->SetUnconstrainedFontSize(true);
+  m_ScalarBarActor->GetLabelTextProperty()->SetItalic(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetShadow(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBold(0);
+  double v[3] = {1.0, 1.0, 1.0};
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundColor(v);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundOpacity(1);
+  m_ScalarBarActor->SetNumberOfLabels(0);
+  // m_ScalarBarActor->SetNumberOf
+}
+
+void mitk::ColorBarAnnotation::Update(mitk::BaseRenderer *renderer)
+{
+  mitk::VtkAnnotation::Update(renderer);
 }
 
 void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
@@ -64,18 +117,32 @@ void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
     ls->m_ScalarBarActor->SetMaximumNumberOfColors(this->GetMaxNumberOfColors());
     ls->m_ScalarBarActor->SetNumberOfLabels(this->GetNumberOfLabels());
     ls->m_ScalarBarActor->SetAnnotationTextScaling(this->GetAnnotationTextScaling());
+
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetFontSize(this->GetFontSize());
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetFontSize(this->GetFontSize());
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetFontSize(this->GetFontSize());
+
+    float color[3];
+    double colord[3];
+    this->GetColor(color);
+    std::copy(color, color + 3, colord);
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetColor(colord);
+
     // manually set position so there is no overlap with mitk logo in 3d renderwindow
+    auto size = renderer->GetViewportSize();
     if (this->GetOrientation() == 1)
     {
-      ls->m_ScalarBarActor->SetPosition(0.80, 0.15);
-      ls->m_ScalarBarActor->SetWidth(0.15);
-      ls->m_ScalarBarActor->SetHeight(0.85);
+      ls->m_ScalarBarActor->SetPosition(0.05, (1.0 - this->GetLenght() / float(size[1])) * 0.5);
+      ls->m_ScalarBarActor->SetWidth(this->GetWidth() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetLenght() / float(size[1]));
     }
     else
     {
-      ls->m_ScalarBarActor->SetPosition(0.03, 0.03);
-      ls->m_ScalarBarActor->SetWidth(0.8);
-      ls->m_ScalarBarActor->SetHeight(0.15);
+      ls->m_ScalarBarActor->SetPosition((1.0 - this->GetLenght() / float(size[0])) * 0.5, 0.05);
+      ls->m_ScalarBarActor->SetWidth(this->GetLenght() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetWidth() / float(size[1]));
     }
   }
 }
diff --git a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
index d07d3dfb93..b07760c899 100644
--- a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
+++ b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
@@ -70,6 +70,7 @@ void mitk::ScaleLegendAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *render
     ls->m_legendScaleActor->GetRightAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetTopAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetBottomAxis()->SetFontFactor(this->GetFontFactor());
+    ls->m_legendScaleActor->SetLabelModeToDistance();
   }
 }
 
diff --git a/Modules/Annotation/src/mitkTextAnnotation2D.cpp b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
index 24fab05733..546607b5b5 100644
--- a/Modules/Annotation/src/mitkTextAnnotation2D.cpp
+++ b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
@@ -29,6 +29,7 @@ mitk::TextAnnotation2D::TextAnnotation2D()
   this->SetBoolProperty("font.bold", false);
   this->SetBoolProperty("font.italic", false);
   this->SetBoolProperty("drawShadow", false);
+  
 }
 
 mitk::TextAnnotation2D::~TextAnnotation2D()
@@ -96,12 +97,17 @@ void mitk::TextAnnotation2D::UpdateVtkAnnotation2D(mitk::BaseRenderer *renderer)
     float opacity = 1.0;
     GetColor(color);
     GetOpacity(opacity);
-    ls->m_TextProp->SetColor(color[0], color[1], color[2]);
     ls->m_STextProp->SetColor(0, 0, 0);
-    ls->m_TextProp->SetFontSize(GetFontSize());
-    ls->m_TextProp->SetOpacity(opacity);
+    //ls->m_STextProp->SetBackgroundColor(1.0, 1.0, 1.0);
+    //ls->m_STextProp->SetBackgroundOpacity(1.0);
     ls->m_STextProp->SetFontSize(GetFontSize());
     ls->m_STextProp->SetOpacity(opacity);
+    
+	ls->m_TextProp->SetColor(color[0], color[1], color[2]);
+    ls->m_TextProp->SetFontSize(GetFontSize());
+    ls->m_TextProp->SetOpacity(opacity);
+    //ls->m_TextProp->SetBackgroundColor(1.0, 1.0, 1.0);
+    //ls->m_TextProp->SetBackgroundOpacity(1.0);
 
     std::string fontFamilyAsString;
     if (GetStringProperty("font.family", fontFamilyAsString) == false)
diff --git a/Modules/AppUtil/src/mitkBaseApplication.cpp b/Modules/AppUtil/src/mitkBaseApplication.cpp
index e41a40fe79..7c47ea5b01 100644
--- a/Modules/AppUtil/src/mitkBaseApplication.cpp
+++ b/Modules/AppUtil/src/mitkBaseApplication.cpp
@@ -660,6 +660,7 @@ namespace mitk
 #endif
 
       QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
+      QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
 
       d->m_QApp = this->getSingleMode()
         ? static_cast<QCoreApplication*>(new QmitkSingleApplication(d->m_Argc, d->m_Argv, this->getSafeMode()))
diff --git a/Modules/Core/CMakeLists.txt b/Modules/Core/CMakeLists.txt
index b38af61df6..2e79dc40ce 100644
--- a/Modules/Core/CMakeLists.txt
+++ b/Modules/Core/CMakeLists.txt
@@ -30,7 +30,7 @@ mitk_create_module(
       #ITK|Statistics+Transform
       VTK|FiltersTexture+FiltersParallel+ImagingStencil+ImagingMath+InteractionStyle+RenderingOpenGL2+RenderingVolumeOpenGL2+RenderingFreeType+RenderingLabel+InteractionWidgets+IOGeometry+IOXML
     PRIVATE
-      ITK|IOBioRad+IOBMP+IOBruker+IOCSV+IOGDCM+IOGE+IOGIPL+IOHDF5+IOIPL+IOJPEG+IOLSM+IOMesh+IOMeta+IOMINC+IOMRC+IONIFTI+IONRRD+IOPNG+IOSiemens+IOSpatialObjects+IOStimulate+IOTIFF+IOTransformBase+IOTransformHDF5+IOTransformInsightLegacy+IOTransformMatlab+IOVTK+IOXML
+      ITK|IOBioRad+IOBMP+IOBruker+IOCSV+IOGDCM+IOGE+IOGIPL+IOHDF5+IOIPL+IOJPEG+IOLSM+IOMesh+IOMeta+IOMINC+IOMRC+IONIFTI+IONRRD+IOPNG+IOSiemens+IOSpatialObjects+IOStimulate+IOTIFF+IOTransformBase+IOTransformHDF5+IOTransformInsightLegacy+IOTransformMatlab+IOVTK+IOXML+IOOpenSlide
       tinyxml2
       ${optional_private_package_depends}
   # Do not automatically create CppMicroServices initialization code.
diff --git a/Modules/Core/TestingHelper/include/mitkTestFixture.h b/Modules/Core/TestingHelper/include/mitkTestFixture.h
index f0c881fae8..5bd9c5910a 100644
--- a/Modules/Core/TestingHelper/include/mitkTestFixture.h
+++ b/Modules/Core/TestingHelper/include/mitkTestFixture.h
@@ -111,6 +111,21 @@ namespace mitk
       return std::string(MITK_DATA_DIR) + "/" + testData;
     }
 
+
+    /**
+     * \brief Get the absolute path for project specific test data.
+     *
+     * \param testData The realative path in the project specific test data repository.
+     *
+     * \return The absolute path for the project specific test data.
+     */
+    static std::string GetTestDataFilePath(const std::string &testData, const std::string &project )
+    {
+      if (itksys::SystemTools::FileIsFullPath(testData.c_str()))
+        return testData;
+      return project + "/" + testData;
+    }
+
   private:
     template <class P>
     friend class TestCaller;
diff --git a/Modules/Core/include/mitkDataStorage.h b/Modules/Core/include/mitkDataStorage.h
index a860959317..7ef6fb8c73 100644
--- a/Modules/Core/include/mitkDataStorage.h
+++ b/Modules/Core/include/mitkDataStorage.h
@@ -66,7 +66,7 @@ namespace mitk
     //##Documentation
     //## @brief Convenience method to add a node that has one parent
     //##
-    void Add(DataNode *node, DataNode *parent);
+    void Add(DataNode *node, const DataNode *parent);
 
     //##Documentation
     //## @brief Removes node from the DataStorage
diff --git a/Modules/Core/include/mitkLookupTable.h b/Modules/Core/include/mitkLookupTable.h
index 5ab7de7dba..d2c1ec2560 100644
--- a/Modules/Core/include/mitkLookupTable.h
+++ b/Modules/Core/include/mitkLookupTable.h
@@ -210,7 +210,10 @@ namespace mitk
       LEGACY_RAINBOW_COLOR,
       MULTILABEL,
       PET_COLOR,
-      PET_20
+      PET_20,
+      GRAYSCALE_TRANSPARENT,
+      HOT_IRON_TRANSPARENT,
+      VIRIDIS_TRANSPARENT
     };
 
     static std::vector<std::string> typenameList;
@@ -244,14 +247,14 @@ namespace mitk
 
     LookupTable(const LookupTable &other);
 
-    virtual void BuildGrayScaleLookupTable();
+    virtual void BuildGrayScaleLookupTable(bool transparent = false);
     virtual void BuildLegacyBinaryLookupTable();
     virtual void BuildLegacyRainbowColorLookupTable();
     virtual void BuildInverseGrayScaleLookupTable();
-    virtual void BuildHotIronLookupTable();
-	  virtual void BuildPlasmaLookupTable();
-	  virtual void BuildInfernoLookupTable();
-	  virtual void BuildViridisLookupTable();
+    virtual void BuildHotIronLookupTable(bool transparent = false);
+    virtual void BuildPlasmaLookupTable();
+	virtual void BuildInfernoLookupTable();
+    virtual void BuildViridisLookupTable(bool transparent = false);
     virtual void BuildMagmaLookupTable();
     virtual void BuildJetLookupTable(bool transparent = false);
     virtual void BuildPETColorLookupTable();
diff --git a/Modules/Core/src/DataManagement/mitkDataStorage.cpp b/Modules/Core/src/DataManagement/mitkDataStorage.cpp
index 5a555a15da..5e7cc3fc5d 100644
--- a/Modules/Core/src/DataManagement/mitkDataStorage.cpp
+++ b/Modules/Core/src/DataManagement/mitkDataStorage.cpp
@@ -36,11 +36,11 @@ mitk::DataStorage::~DataStorage()
   // m_NodeDeleteObserverTags.clear();
 }
 
-void mitk::DataStorage::Add(DataNode *node, DataNode *parent)
+void mitk::DataStorage::Add(DataNode *node, const DataNode *parent)
 {
   DataStorage::SetOfObjects::Pointer parents = DataStorage::SetOfObjects::New();
   if (parent != nullptr) //< Return empty set if parent is null
-    parents->InsertElement(0, parent);
+    parents->InsertElement(0, const_cast<DataNode *>(parent));
   this->Add(node, parents);
 }
 
diff --git a/Modules/Core/src/DataManagement/mitkImage.cpp b/Modules/Core/src/DataManagement/mitkImage.cpp
index 4ed855b751..381bd0aebe 100644
--- a/Modules/Core/src/DataManagement/mitkImage.cpp
+++ b/Modules/Core/src/DataManagement/mitkImage.cpp
@@ -939,7 +939,7 @@ void mitk::Image::Initialize(const mitk::PixelType &type,
   dimensions[4] = 0;
 
   unsigned int dimension = 2;
-  if (dimensions[2] > 1)
+  if (dimensions[2] >= 1)
     dimension = 3;
   if (dimensions[3] > 1)
     dimension = 4;
diff --git a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
index c0b04c6570..f8ac8f7d8d 100644
--- a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
+++ b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
@@ -555,7 +555,8 @@ mitk::DataStorage::SetOfObjects::ConstPointer mitk::LevelWindowManager::GetRelev
   NodePredicateProperty::Pointer notBinary = NodePredicateProperty::New("binary", BoolProperty::New(false));
   NodePredicateProperty::Pointer hasLevelWindow = NodePredicateProperty::New("levelwindow", nullptr);
 
-  NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  //NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  auto isImage = TNodePredicateDataType<mitk::Image>::New();
   NodePredicateDataType::Pointer isDImage = NodePredicateDataType::New("DiffusionImage");
   NodePredicateDataType::Pointer isTImage = NodePredicateDataType::New("TensorImage");
   NodePredicateDataType::Pointer isOdfImage = NodePredicateDataType::New("OdfImage");
diff --git a/Modules/Core/src/DataManagement/mitkLookupTable.cpp b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
index 3022e09869..613c2f7249 100644
--- a/Modules/Core/src/DataManagement/mitkLookupTable.cpp
+++ b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
@@ -17,57 +17,56 @@ found in the LICENSE file.
 #include <vtkPiecewiseFunction.h>
 
 #include <Colortables/HotIron.h>
-#include <Colortables/Jet.h>
 #include <Colortables/Inferno.h>
-#include <Colortables/Viridis.h>
-#include <Colortables/Plasma.h>
+#include <Colortables/Jet.h>
 #include <Colortables/Magma.h>
 #include <Colortables/Multilabel.h>
 #include <Colortables/PET20.h>
 #include <Colortables/PETColor.h>
+#include <Colortables/Plasma.h>
+#include <Colortables/Viridis.h>
 #include <mitkLookupTableProperty.h>
 
-std::vector<std::string> mitk::LookupTable::typenameList = {
-  "Grayscale",
-  "Inverse Grayscale",
-  "Hot Iron",
-  "Jet",
-  "Jet Transparent",
-  "Plasma",
-  "Inferno",
-  "Viridis",
-  "Magma",
-  "Legacy Binary",
-  "Legacy Rainbow Color",
-  "Multilabel",
-  "PET Color",
-  "PET 20"
-};
+std::vector<std::string> mitk::LookupTable::typenameList = {"Grayscale",
+                                                            "Inverse Grayscale",
+                                                            "Hot Iron",
+                                                            "Jet",
+                                                            "Jet Transparent",
+                                                            "Plasma",
+                                                            "Inferno",
+                                                            "Viridis",
+                                                            "Magma",
+                                                            "Legacy Binary",
+                                                            "Legacy Rainbow Color",
+                                                            "Multilabel",
+                                                            "PET Color",
+                                                            "PET 20",
+                                                            "Grayscale Transparent",
+                                                            "Hot Iron Transparent",
+                                                            "Viridis Transparent"};
 
 mitk::LookupTable::LookupTable()
-  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(0.0)
-  , m_Level(0.0)
-  , m_Opacity(1.0)
-  , m_Type(mitk::LookupTable::GRAYSCALE)
+  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(0.0),
+    m_Level(0.0),
+    m_Opacity(1.0),
+    m_Type(mitk::LookupTable::GRAYSCALE)
 {
   this->BuildGrayScaleLookupTable();
 }
 
 mitk::LookupTable::LookupTable(const LookupTable &other)
-  : itk::DataObject()
-  , m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(other.m_Window)
-  , m_Level(other.m_Level)
-  , m_Opacity(other.m_Opacity)
-  , m_Type(other.m_Type)
+  : itk::DataObject(),
+    m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(other.m_Window),
+    m_Level(other.m_Level),
+    m_Opacity(other.m_Opacity),
+    m_Type(other.m_Type)
 {
   m_LookupTable->DeepCopy(other.m_LookupTable);
 }
 
-mitk::LookupTable::~LookupTable()
-{
-}
+mitk::LookupTable::~LookupTable() {}
 
 void mitk::LookupTable::SetVtkLookupTable(vtkSmartPointer<vtkLookupTable> lut)
 {
@@ -87,6 +86,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
 
   switch (type)
   {
+    case (mitk::LookupTable::GRAYSCALE_TRANSPARENT):
+      this->BuildGrayScaleLookupTable(true);
+      break;
     case (mitk::LookupTable::GRAYSCALE):
       this->BuildGrayScaleLookupTable();
       break;
@@ -96,6 +98,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
     case (mitk::LookupTable::HOT_IRON):
       this->BuildHotIronLookupTable();
       break;
+    case (mitk::LookupTable::HOT_IRON_TRANSPARENT):
+      this->BuildHotIronLookupTable(true);
+      break;
     case (mitk::LookupTable::JET):
       this->BuildJetLookupTable();
       break;
@@ -103,14 +108,17 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
       this->BuildJetLookupTable(true);
       break;
     case (mitk::LookupTable::PLASMA):
-	    this->BuildPlasmaLookupTable();
-	    break;
-	  case (mitk::LookupTable::INFERNO):
-	    this->BuildInfernoLookupTable();
+      this->BuildPlasmaLookupTable();
+      break;
+    case (mitk::LookupTable::INFERNO):
+      this->BuildInfernoLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS):
+      this->BuildViridisLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS_TRANSPARENT):
+      this->BuildViridisLookupTable(true);
       break;
-	  case (mitk::LookupTable::VIRIDIS):
-	    this->BuildViridisLookupTable();
-	    break;
     case (mitk::LookupTable::MAGMA):
       this->BuildMagmaLookupTable();
       break;
@@ -285,9 +293,7 @@ void mitk::LookupTable::UpdateOutputInformation()
   }
 }
 
-void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion()
-{
-}
+void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion() {}
 
 bool mitk::LookupTable::RequestedRegionIsOutsideOfTheBufferedRegion()
 {
@@ -411,7 +417,7 @@ itk::LightObject::Pointer mitk::LookupTable::InternalClone() const
   return result;
 }
 
-void mitk::LookupTable::BuildGrayScaleLookupTable()
+void mitk::LookupTable::BuildGrayScaleLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetRampToLinear();
@@ -420,6 +426,11 @@ void mitk::LookupTable::BuildGrayScaleLookupTable()
   lut->SetValueRange(0.0, 1.0);
   lut->Build();
 
+  if (transparent)
+  {
+    lut->SetTableValue(0, 0.0, 0.0, 0.0, 0.0);
+  }
+
   m_LookupTable = lut;
   this->Modified();
 }
@@ -452,13 +463,22 @@ void mitk::LookupTable::BuildInverseGrayScaleLookupTable()
   this->Modified();
 }
 
-void mitk::LookupTable::BuildHotIronLookupTable()
+void mitk::LookupTable::BuildHotIronLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetNumberOfTableValues(256);
   lut->Build();
+  int i = 0;
 
-  for (int i = 0; i < 256; i++)
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)HotIron[0][0] / 255.0, (double)HotIron[0][1] / 255.0, (double)HotIron[0][2] / 255.0, 0.0);
+    i = 1;
+  }
+
+  for (; i < 256; i++)
   {
     lut->SetTableValue(
       i, (double)HotIron[i][0] / 255.0, (double)HotIron[i][1] / 255.0, (double)HotIron[i][2] / 255.0, 1.0);
@@ -535,7 +555,7 @@ void mitk::LookupTable::BuildMultiLabelLookupTable()
 
   for (int i = 0; i < 25; i++)
   {
-    lut->SetTableValue(i+1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
+    lut->SetTableValue(i + 1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
   }
 
   for (int i = 26; i < 65536; i++)
@@ -584,50 +604,59 @@ void mitk::LookupTable::BuildLegacyRainbowColorLookupTable()
 
 void mitk::LookupTable::BuildPlasmaLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
-	}
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildInfernoLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
-	}
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
-void mitk::LookupTable::BuildViridisLookupTable()
+void mitk::LookupTable::BuildViridisLookupTable(bool transparent)
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
+
+  int i = 0;
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)Viridis[0][0] / 255.0, (double)Viridis[0][1] / 255.0, (double)Viridis[0][2] / 255.0, 0.0);
+    i = 1;
+  }
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
-	}
+  for (; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildMagmaLookupTable()
@@ -638,8 +667,7 @@ void mitk::LookupTable::BuildMagmaLookupTable()
 
   for (int i = 0; i < 256; i++)
   {
-    lut->SetTableValue(
-      i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
+    lut->SetTableValue(i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
   }
 
   m_LookupTable = lut;
diff --git a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
index cfecd85744..8c40ae6d85 100644
--- a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
+++ b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
@@ -147,7 +147,7 @@ void mitk::PointSetDataInteractor::SelectPoint(StateMachineAction *, Interaction
   }
 }
 
-mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(3.5)
+mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(0.025)
 {
 }
 
diff --git a/Modules/Core/src/Rendering/mitkImageVtkMapper2D.cpp b/Modules/Core/src/Rendering/mitkImageVtkMapper2D.cpp
index 5e4e797c38..60e4883cf8 100644
--- a/Modules/Core/src/Rendering/mitkImageVtkMapper2D.cpp
+++ b/Modules/Core/src/Rendering/mitkImageVtkMapper2D.cpp
@@ -624,6 +624,14 @@ void mitk::ImageVtkMapper2D::ApplyLookuptable(mitk::BaseRenderer *renderer)
 {
   LocalStorage *localStorage = m_LSH.GetLocalStorage(renderer);
   vtkLookupTable *usedLookupTable = localStorage->m_ColorLookupTable;
+  
+ /* auto lookuptable_updatelater = this->GetDataNode()->GetProperty("LookupTable_updatelater", renderer);
+  if (lookuptable_updatelater)
+  {
+    auto lutProp = dynamic_cast<mitk::LookupTableProperty *>(lookuptable_updatelater);
+    this->GetDataNode()->SetProperty("LookupTable", lutProp);
+    this->GetDataNode()->RemoveProperty("LookupTable_updatelater");
+  }*/
 
   // If lookup table or transferfunction use is requested...
   mitk::LookupTableProperty::Pointer lookupTableProp =
diff --git a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
index 623924f0b3..f549e3610a 100644
--- a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
+++ b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
@@ -17,6 +17,7 @@ found in the LICENSE file.
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkNodePredicateNot.h>
+#include <mitkImage.h>
 
 namespace mitk
 {
@@ -30,7 +31,7 @@ namespace mitk
 
   mitk::NodePredicateBase::Pointer GetImageStatisticsImagePredicate()
   {
-    auto isImage = mitk::NodePredicateDataType::New("Image");
+    auto isImage = mitk::TNodePredicateDataType<mitk::Image>::New();
     auto hasBinaryProperty = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
     auto isNotBinary = mitk::NodePredicateNot::New(hasBinaryProperty);
     auto isNotBinaryImage = mitk::NodePredicateAnd::New(isImage, isNotBinary);
diff --git a/Modules/MapperExt/src/vtkMitkGPUVolumeRayCastMapper.cpp b/Modules/MapperExt/src/vtkMitkGPUVolumeRayCastMapper.cpp
index 7858b5a49d..1aaf77ba59 100644
--- a/Modules/MapperExt/src/vtkMitkGPUVolumeRayCastMapper.cpp
+++ b/Modules/MapperExt/src/vtkMitkGPUVolumeRayCastMapper.cpp
@@ -50,8 +50,8 @@ vtkMitkGPUVolumeRayCastMapper::vtkMitkGPUVolumeRayCastMapper()
 {
   this->AutoAdjustSampleDistances = 1;
   this->ImageSampleDistance = 1.0;
-  this->MinimumImageSampleDistance = 1.0;
-  this->MaximumImageSampleDistance = 10.0;
+  this->MinimumImageSampleDistance = 0.0;
+  this->MaximumImageSampleDistance = 100.0;
   this->SampleDistance = 1.0;
   this->SmallVolumeRender = 0;
   this->BigTimeToDraw = 0.0;
diff --git a/Modules/QtWidgets/src/QmitkDataStorageComboBoxWithSelectNone.cpp b/Modules/QtWidgets/src/QmitkDataStorageComboBoxWithSelectNone.cpp
index dacc7ea0d3..d7203263e5 100644
--- a/Modules/QtWidgets/src/QmitkDataStorageComboBoxWithSelectNone.cpp
+++ b/Modules/QtWidgets/src/QmitkDataStorageComboBoxWithSelectNone.cpp
@@ -19,6 +19,7 @@ QmitkDataStorageComboBoxWithSelectNone::QmitkDataStorageComboBoxWithSelectNone(Q
   : QmitkDataStorageComboBox(parent, autoSelectNewNodes)
   , m_CurrentPath("")
 {
+  Reset();
 }
 
 QmitkDataStorageComboBoxWithSelectNone::QmitkDataStorageComboBoxWithSelectNone(mitk::DataStorage* dataStorage,
@@ -27,6 +28,7 @@ QmitkDataStorageComboBoxWithSelectNone::QmitkDataStorageComboBoxWithSelectNone(m
                                                                                bool autoSelectNewNodes)
   : QmitkDataStorageComboBox(dataStorage, predicate, parent, autoSelectNewNodes)
 {
+  Reset();
 }
 
 QmitkDataStorageComboBoxWithSelectNone::~QmitkDataStorageComboBoxWithSelectNone()
diff --git a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
index 46a8600375..2f4cf06ef2 100644
--- a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
+++ b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
@@ -13,10 +13,12 @@ found in the LICENSE file.
 #include "QmitkNodeDescriptorManager.h"
 #include <memory>
 #include <mitkNodePredicateAnd.h>
+#include <mitkNodePredicateOr.h>
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateNot.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkProperties.h>
+#include <mitkImage.h>
 
 #include <QList>
 #include <QSet>
@@ -35,6 +37,15 @@ void QmitkNodeDescriptorManager::Initialize()
   auto isMultiComponentImage = mitk::NodePredicateAnd::New(isImage, mitk::NodePredicateProperty::New("Image.Displayed Component"));
   AddDescriptor(new QmitkNodeDescriptor(tr("MultiComponentImage"), QString(": / Qmitk / Images_48.png"), isMultiComponentImage, this));
 
+  auto a = mitk::NodePredicateDataType::New("MassSpecImageBase");
+  auto b = mitk::NodePredicateDataType::New("ImzMLMassSpecImage");
+  auto c = mitk::NodePredicateOr::New(a, b);
+  auto d = mitk::NodePredicateDataType::New("TransformixMSDataObjectStack");
+  auto e = mitk::NodePredicateOr::New(c, d);
+  auto f = mitk::TNodePredicateDataType<mitk::Image>::New();
+  auto g = mitk::NodePredicateAnd::New(e, f);
+  AddDescriptor( new QmitkNodeDescriptor(tr("MassSpecImage"), QString(":/Qmitk/LabelSetImage_48.png"), g, this));
+
   auto isBinary = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
   auto isBinaryImage = mitk::NodePredicateAnd::New(isBinary, isImage);
   AddDescriptor(new QmitkNodeDescriptor(tr("ImageMask"), QString(":/Qmitk/Binaerbilder_48.png"), isBinaryImage, this));
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
index a8a7e00ce6..e4de87c85a 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
@@ -11,7 +11,16 @@ found in the LICENSE file.
 ============================================================================*/
 
 #include <QmitkDataNodeContextMenu.h>
+#include "QmitkDataNodeContextMenu.h"
 
+// mitk gui qt application plugin
+#include "QmitkFileSaveAction.h"
+#include "mitkIContextMenuAction.h"
+
+// mitk gui common plugin
+#include <mitkDataNodeSelection.h>
+
+// qt widgets module
 #include <QmitkCustomVariants.h>
 #include <QmitkFileSaveAction.h>
 #include <QmitkNodeDescriptorManager.h>
@@ -41,7 +50,7 @@ QmitkDataNodeContextMenu::~QmitkDataNodeContextMenu()
     descriptorActionPair.first->RemoveAction(descriptorActionPair.second);
 }
 
-void QmitkDataNodeContextMenu::SetDataStorage(mitk::DataStorage* dataStorage)
+void QmitkDataNodeContextMenu::SetDataStorage(mitk::DataStorage *dataStorage)
 {
   m_DataStorage = dataStorage;
 
@@ -54,7 +63,7 @@ void QmitkDataNodeContextMenu::SetDataStorage(mitk::DataStorage* dataStorage)
   }  
 }
 
-void QmitkDataNodeContextMenu::SetBaseRenderer(mitk::BaseRenderer* baseRenderer)
+void QmitkDataNodeContextMenu::SetBaseRenderer(mitk::BaseRenderer *baseRenderer)
 {
   m_BaseRenderer = baseRenderer;
 
@@ -72,13 +81,14 @@ void QmitkDataNodeContextMenu::SetSurfaceDecimation(bool surfaceDecimation)
   m_SurfaceDecimation = surfaceDecimation;
 }
 
-void QmitkDataNodeContextMenu::SetSelectedNodes(const QList<mitk::DataNode::Pointer>& selectedNodes)
+void QmitkDataNodeContextMenu::SetSelectedNodes(const QList<mitk::DataNode::Pointer> &selectedNodes)
 {
   m_SelectedNodes = selectedNodes;
 }
 
 void QmitkDataNodeContextMenu::InitNodeDescriptors()
 {
+
   auto nodeDescriptorManager = QmitkNodeDescriptorManager::GetInstance();
 
   m_UnknownDataNodeDescriptor = nodeDescriptorManager->GetUnknownDataNodeDescriptor();
@@ -101,6 +111,8 @@ void QmitkDataNodeContextMenu::InitNodeDescriptors()
   m_PlanarDoubleEllipseNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarDoubleEllipse");
   m_PlanarBezierCurveNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarBezierCurve");
   m_PlanarSubdivisionPolygonNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarSubdivisionPolygon");
+  m_ImzMLMassSpecImageNodeDescriptor = nodeDescriptorManager->GetDescriptor("MassSpecImage");
+
 }
 
 void QmitkDataNodeContextMenu::InitDefaultActions()
@@ -118,6 +130,7 @@ void QmitkDataNodeContextMenu::InitDefaultActions()
   m_DescriptorActionList.push_back(std::make_pair(m_UnknownDataNodeDescriptor, m_ReinitAction));
 
   QAction* saveAction = new QmitkFileSaveAction(QIcon(":/org.mitk.gui.qt.datamanager/Save_48.png"), workbenchPartSite->GetWorkbenchWindow());
+
   m_UnknownDataNodeDescriptor->AddAction(saveAction, true);
   m_DescriptorActionList.push_back(std::make_pair(m_UnknownDataNodeDescriptor, saveAction));
 
@@ -145,48 +158,49 @@ void QmitkDataNodeContextMenu::InitDefaultActions()
   m_UnknownDataNodeDescriptor->AddAction(m_OpacityAction, false);
   m_DescriptorActionList.push_back(std::make_pair(m_UnknownDataNodeDescriptor, m_OpacityAction));
 
-  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, workbenchPartSite);
-  this->AddColorAction(m_ColorAction);
-
-  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_ColormapAction);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_ColormapAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ColormapAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ColormapAction));
-  }
-
-  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, workbenchPartSite);
-  m_MultiComponentImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, m_ComponentAction));
+  auto all = {m_ImageDataNodeDescriptor,
+              m_ImzMLMassSpecImageNodeDescriptor,
+              m_MultiComponentImageDataNodeDescriptor,
+              m_DiffusionImageDataNodeDescriptor,
+              m_FiberBundleDataNodeDescriptor,
+              m_PeakImageDataNodeDescriptor,
+              m_SegmentDataNodeDescriptor,
+              m_SurfaceDataNodeDescriptor,
+              m_PointSetNodeDescriptor,
+              m_PlanarLineNodeDescriptor,
+              m_PlanarCircleNodeDescriptor,
+              m_PlanarEllipseNodeDescriptor,
+              m_PlanarAngleNodeDescriptor,
+              m_PlanarFourPointAngleNodeDescriptor,
+              m_PlanarRectangleNodeDescriptor,
+              m_PlanarPolygonNodeDescriptor,
+              m_PlanarPathNodeDescriptor,
+              m_PlanarDoubleEllipseNodeDescriptor,
+              m_PlanarBezierCurveNodeDescriptor,
+              m_PlanarSubdivisionPolygonNodeDescriptor};
+
+  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColorAction, all, true);
+
+  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColormapAction,
+            {m_ImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor, m_ImzMLMassSpecImageNodeDescriptor},
+            true);
+
+  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ComponentAction, {m_MultiComponentImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor}, false);
+
+  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_TextureInterpolationAction,
+            {m_ImageDataNodeDescriptor,
+             m_DiffusionImageDataNodeDescriptor,
+             m_ImzMLMassSpecImageNodeDescriptor,
+             m_SegmentDataNodeDescriptor},
+            false);
+
+  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_SurfaceRepresentationAction, {m_SurfaceDataNodeDescriptor}, false);
 
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ComponentAction));
-  }
-
-  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_TextureInterpolationAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_TextureInterpolationAction));
-  }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, m_TextureInterpolationAction));
-  }
-
-  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, workbenchPartSite);
-  m_SurfaceDataNodeDescriptor->AddAction(m_SurfaceRepresentationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, m_SurfaceRepresentationAction));
 }
 
 void QmitkDataNodeContextMenu::InitExtensionPointActions()
@@ -194,7 +208,9 @@ void QmitkDataNodeContextMenu::InitExtensionPointActions()
   auto extensionPointService = berry::Platform::GetExtensionRegistry();
   auto customMenuConfigs = extensionPointService->GetConfigurationElementsFor("org.mitk.gui.qt.datamanager.contextMenuActions");
 
+
   DescriptorActionListType descriptorActionList;
+
   m_ConfigElements.clear();
 
   for (const auto& customMenuConfig : qAsConst(customMenuConfigs))
@@ -247,11 +263,9 @@ void QmitkDataNodeContextMenu::InitExtensionPointActions()
   this->AddDescriptorActionList(descriptorActionList);
 }
 
-void QmitkDataNodeContextMenu::InitServiceActions()
-{
-}
+void QmitkDataNodeContextMenu::InitServiceActions() {}
 
-void QmitkDataNodeContextMenu::OnContextMenuRequested(const QPoint& /*pos*/)
+void QmitkDataNodeContextMenu::OnContextMenuRequested(const QPoint & /*pos*/)
 {
   if (m_WorkbenchPartSite.Expired())
     return;
@@ -266,6 +280,7 @@ void QmitkDataNodeContextMenu::OnContextMenuRequested(const QPoint& /*pos*/)
 
   if (!m_SelectedNodes.isEmpty())
   {
+
     this->clear();
 
     auto actions = m_SelectedNodes.size() == 1
@@ -287,6 +302,7 @@ void QmitkDataNodeContextMenu::OnContextMenuRequested(const QPoint& /*pos*/)
 
 void QmitkDataNodeContextMenu::OnExtensionPointActionTriggered(QAction* action)
 {
+
   auto configElementIter = m_ConfigElements.find(action);
 
   if (m_ConfigElements.end() == configElementIter)
@@ -295,6 +311,7 @@ void QmitkDataNodeContextMenu::OnExtensionPointActionTriggered(QAction* action)
     return;
   }
 
+
   auto configElement = configElementIter->second;
   auto contextMenuAction = configElement->CreateExecutableExtension<mitk::IContextMenuAction>("class");
 
@@ -310,125 +327,22 @@ void QmitkDataNodeContextMenu::OnExtensionPointActionTriggered(QAction* action)
   contextMenuAction->Run(m_SelectedNodes);
 }
 
-void QmitkDataNodeContextMenu::AddColorAction(QWidgetAction* colorAction)
+void QmitkDataNodeContextMenu::AddAction(QAction *action, std::vector<QmitkNodeDescriptor *> list, bool canBatch)
 {
-  if (nullptr != m_ImageDataNodeDescriptor)
-  {
-    m_ImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_MultiComponentImageDataNodeDescriptor)
-  {
-    m_MultiComponentImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_FiberBundleDataNodeDescriptor)
-  {
-    m_FiberBundleDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_FiberBundleDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PeakImageDataNodeDescriptor)
-  {
-    m_PeakImageDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_PeakImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_SurfaceDataNodeDescriptor)
-  {
-    m_SurfaceDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PointSetNodeDescriptor)
-  {
-    m_PointSetNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PointSetNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarLineNodeDescriptor)
-  {
-    m_PlanarLineNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarLineNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarCircleNodeDescriptor)
-  {
-    m_PlanarCircleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarCircleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarEllipseNodeDescriptor)
-  {
-    m_PlanarEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarAngleNodeDescriptor)
-  {
-    m_PlanarAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarAngleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarFourPointAngleNodeDescriptor)
-  {
-    m_PlanarFourPointAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarFourPointAngleNodeDescriptor, colorAction));
-  }
 
-  if (nullptr != m_PlanarRectangleNodeDescriptor)
+  for (auto *descriptor : list)
   {
-    m_PlanarRectangleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarRectangleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPolygonNodeDescriptor)
-  {
-    m_PlanarPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPolygonNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPathNodeDescriptor)
-  {
-    m_PlanarPathNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPathNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarDoubleEllipseNodeDescriptor)
-  {
-    m_PlanarDoubleEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarDoubleEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarBezierCurveNodeDescriptor)
-  {
-    m_PlanarBezierCurveNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarBezierCurveNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarSubdivisionPolygonNodeDescriptor)
-  {
-    m_PlanarSubdivisionPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarSubdivisionPolygonNodeDescriptor, colorAction));
+    if (nullptr != descriptor)
+    {
+      descriptor->AddAction(action, canBatch);
+      m_DescriptorActionList.push_back(std::make_pair(descriptor, action));
+    }
   }
 }
 
-void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType& descriptorActionList)
+void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType &descriptorActionList)
 {
+
   using ListItem = std::pair<QmitkNodeDescriptor*, QAction*>;
 
   std::sort(descriptorActionList.begin(), descriptorActionList.end(), [](const ListItem& left, const ListItem& right) -> bool
@@ -443,8 +357,9 @@ void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType&
   }
 }
 
-QList<QAction*> QmitkDataNodeContextMenu::GetActions(const mitk::DataNode* node)
+QList<QAction *> QmitkDataNodeContextMenu::GetActions(const mitk::DataNode *node)
 {
+
   QList<QAction*> actions;
 
   for(const auto& descriptorActionPair : m_DescriptorActionList)
@@ -456,14 +371,16 @@ QList<QAction*> QmitkDataNodeContextMenu::GetActions(const mitk::DataNode* node)
   return actions;
 }
 
-QList<QAction*> QmitkDataNodeContextMenu::GetActions(const QList<mitk::DataNode::Pointer>& nodes)
+QList<QAction *> QmitkDataNodeContextMenu::GetActions(const QList<mitk::DataNode::Pointer> &nodes)
 {
-  QList<QAction*> actions;
+  QList<QAction *> actions;
+
 
   for (const auto& descriptorActionPair : m_DescriptorActionList)
   {
-    for (const auto& node : nodes)
+    for (const auto &node : nodes)
     {
+
       if (descriptorActionPair.first->CheckNode(node) || "Unknown" == descriptorActionPair.first->GetNameOfClass())
       {
         auto batchActions = descriptorActionPair.first->GetBatchActions();
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
index 2dcf8ba901..3428e42c02 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
@@ -74,7 +74,7 @@ private:
   void InitExtensionPointActions();
   void InitServiceActions();
 
-  void AddColorAction(QWidgetAction* colorAction);
+  void AddAction(QAction *colorAction, std::vector<QmitkNodeDescriptor *> list, bool canBatch = false);
   void AddDescriptorActionList(DescriptorActionListType& descriptorActionList);
 
   QList<QAction*> GetActions(const mitk::DataNode* node);
@@ -113,6 +113,7 @@ private:
   QmitkNodeDescriptor* m_PlanarDoubleEllipseNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarBezierCurveNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarSubdivisionPolygonNodeDescriptor;
+  QmitkNodeDescriptor* m_ImzMLMassSpecImageNodeDescriptor;
 
   //////////////////////////////////////////////////////////////////////////
   // default actions
diff --git a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
index d301680b15..61665c7e4f 100644
--- a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
+++ b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
@@ -159,7 +159,7 @@ void QmitkMultiWidgetDecorationManager::SetupLogo(const char* path)
   mitk::Point2D offset;
   offset.Fill(0.03);
   m_LogoAnnotation->SetOffsetVector(offset);
-  m_LogoAnnotation->SetRelativeSize(0.25);
+  m_LogoAnnotation->SetRelativeSize(0.15);
   m_LogoAnnotation->SetCornerPosition(1);
   vtkSmartPointer<vtkImageData> vtkLogo = GetVtkLogo(path);
 
diff --git a/Plugins/org.mitk.gui.qt.datamanager/src/QmitkDataManagerView.cpp b/Plugins/org.mitk.gui.qt.datamanager/src/QmitkDataManagerView.cpp
index 27b424aafd..89e6fc8105 100644
--- a/Plugins/org.mitk.gui.qt.datamanager/src/QmitkDataManagerView.cpp
+++ b/Plugins/org.mitk.gui.qt.datamanager/src/QmitkDataManagerView.cpp
@@ -175,7 +175,7 @@ void QmitkDataManagerView::SetFocus()
 void QmitkDataManagerView::NodeTreeViewRowsInserted(const QModelIndex& parent, int /*start*/, int /*end*/)
 {
   QModelIndex viewIndex = m_FilterModel->mapFromSource(parent);
-  m_NodeTreeView->setExpanded(viewIndex, true);
+  m_NodeTreeView->setExpanded(viewIndex, false);
 
   // a new row was inserted
   if (m_CurrentRowCount == 0 && m_NodeTreeModel->rowCount() == 1)
diff --git a/Plugins/org.mitk.gui.qt.ext/src/internal/QmitkExternalProgramsPreferencePage.cpp b/Plugins/org.mitk.gui.qt.ext/src/internal/QmitkExternalProgramsPreferencePage.cpp
index 6f2257760f..a2f12d5e08 100644
--- a/Plugins/org.mitk.gui.qt.ext/src/internal/QmitkExternalProgramsPreferencePage.cpp
+++ b/Plugins/org.mitk.gui.qt.ext/src/internal/QmitkExternalProgramsPreferencePage.cpp
@@ -68,15 +68,15 @@ void QmitkExternalProgramsPreferencePage::CreateQtControl(QWidget* parent)
 
 void QmitkExternalProgramsPreferencePage::OnFFmpegButtonClicked()
 {
-  QString filter = "ffmpeg executable ";
+  QString filter = "ffmpeg/avconv executable ";
 
 #if defined(WIN32)
-  filter += "(ffmpeg.exe)";
+  filter += "(ffmpeg.exe avconv.exe)";
 #else
-  filter += "(ffmpeg)";
+  filter += "(ffmpeg avconv)";
 #endif
 
-  QString ffmpegPath = QFileDialog::getOpenFileName(m_Control, "FFmpeg", "", filter);
+  QString ffmpegPath = QFileDialog::getOpenFileName(m_Control, "FFmpeg/Libav", "", filter);
 
   if (!ffmpegPath.isEmpty())
   {
@@ -97,7 +97,7 @@ void QmitkExternalProgramsPreferencePage::OnFFmpegProcessFinished(int exitCode,
   {
     QString output = QTextCodec::codecForName("UTF-8")->toUnicode(m_FFmpegProcess->readAllStandardOutput());
 
-    if (output.startsWith("ffmpeg"))
+    if (output.startsWith("ffmpeg") || output.startsWith("avconv"))
     {
       m_Ui->ffmpegLineEdit->setText(m_FFmpegPath);
       return;
diff --git a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
index dfbd27ae6a..1c40749014 100755
--- a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
+++ b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
@@ -47,7 +47,7 @@ void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
       mitk::NodePredicateProperty::New("hidden object")))));
 
   m_Controls->selectedPointSetWidget->SetSelectionIsOptional(true);
-  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(true);
+  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(false);
   m_Controls->selectedPointSetWidget->SetEmptyInfo(QString("Please select a point set"));
   m_Controls->selectedPointSetWidget->SetPopUpTitel(QString("Select point set"));
 
@@ -68,6 +68,7 @@ void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
 void QmitkPointSetInteractionView::SetFocus()
 {
   m_Controls->addPointSetPushButton->setFocus();
+
 }
 
 void QmitkPointSetInteractionView::OnCurrentSelectionChanged(QmitkSingleNodeSelectionWidget::NodeList /*nodes*/)
diff --git a/SuperBuild.cmake b/SuperBuild.cmake
index b83484ef43..22d104a7d2 100644
--- a/SuperBuild.cmake
+++ b/SuperBuild.cmake
@@ -211,6 +211,22 @@ set(mitk_depends )
 
 # Include external projects
 include(CMakeExternals/MITKData.cmake)
+
+
+foreach(MITK_EXTENSION_DIR ${MITK_EXTENSION_DIRS})
+  set(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_EXTENSION_DIR}/CMakeExternals)
+  get_filename_component(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR} ABSOLUTE)
+  FILE(GLOB MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR}/*Data.cmake)
+  foreach(MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES})
+    if(EXISTS ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+        include(${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+    endif()
+  endforeach()
+endforeach()
+
+
+
+
 foreach(p ${external_projects})
   set(p_hash "")
 
